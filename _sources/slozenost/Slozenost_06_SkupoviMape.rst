Скупови и мапе (речници)
========================

Скупови
-------

У програмима често имамо потребе да одржавамо скуп елемената (без
дупликата), у који ефикасно можемо да додајемо елементе, из кога
ефикасно можемо да избацујемо елементе и тако да ефикасно можемо да
проверавамо да ли је нека задата вредност елемент скупа. Савремени
програмски језици у својим библиотекама пружају структуре података које
нуде баш ове операције.

У језику C# скуп је подржан кроз две класе: ``SortedSet<Т>`` и
``HashSet<Т>``, где је ``Т`` тип елемената скупа. Имплементација је
различита (прва је задата на балансираним бинарним дрветима, а друга на
хеш таблицама), па су им временске и просторне карактеристике донекле
различите.

Скупови подржавају следеће основне операције (за преглед свих операција
упућујемо читаоца на документацију):

-  ``Add`` - умеће нови елемент у скуп (ако већ постоји, операција нема
   ефекта). Када се користи ``SortedSet`` сложеност уметања је
   ``O(\log{k})``, где је ``k`` број елемената у скупу, а када се
   користи ``HashSet``, сложеност најгорег случаја је :math:`O(k)`, док
   је просечна сложеност :math:`O(1)`, при чему је амортизована
   сложеност узастопног додавања већег броја елемената такође
   :math:`O(1)`. Нагласимо и да константе код сложености :math:`О(1)`` могу бити
   релативно велике и да уметање не можемо сматрати јако брзом
   операцијом. Честа операција је додавање :math:`n` елемената у скуп.
   Најгора сложеност је ако су сви различити и износи приближно
   :math:`\log{1} + \log{2} + \ldots + \log{n}`, за шта се може показати
   да је :math:`O(n \log{n})`.

-  ``Remove`` - уклања дати елемент из скупа. Сложеност је иста као у
   случају уметања.

-  ``Contains`` - проверава да ли скуп садржи дати елемент. Сложеност
   најгорег случаја ове операције ако се користи ``SortedSet`` је
   :math:`O(\log{k})`, а ако се користи ``HashSet`` сложеност најгорег
   случаја је :math:`O(k)`, али је просечна сложеност :math:`O(1)`.

Коришћењем скупа можемо лако елиминисати дупликате из низа.

.. code:: csharp

   using System;
   using System.Collections.Generic;
    
   class Program
   {
       static void Main(string[] args)
       {
           // ucitavamo elemente u skup
           var a = new SortedSet<uint>();
           int n = int.Parse(Console.ReadLine());
           for (int i = 0; i < n; i++)
               a.Add(uint.Parse(Console.ReadLine()));
           // ispisujemo broj elemenata skupa
           Console.WriteLine(a.Count);
       }
   }

   
Мапе (речници)
--------------

Програмски језик C# пружа подршку за креирање речника (мапа,
асоцијативних низова) који представљају колекције података у којима се
кључевима неког типа придружују вредности неког типа (не обавезно
истог). На пример, именима месеци (подацима типа ``string``) можемо
доделити број дана (податке типа ``int``). Речници се представљају
објектима типа ``Dictionary<TipKljuca, TipVrednosti>`` из библиотеке
``System.Collections.Generic``. На пример,

.. code:: csharp

   var brojDana = new Dictionary<string, int>()
   {
       {"januar", 31},
       {"februar", 28},
       {"mart", 31},
       ...
   };

Приметимо да смо речник морали да креирамо помоћу кључне речи ``new`` и
да смо након тога навели листу парова облика ``{kljuc, vrednost}``.
Речник није неопходно иницијализовати одмах током креирања, већ је
вредности могуће додавати (а и читати) коришћењем индексног приступа
(помоћу заграда ``[]``).

.. code:: csharp

   var brojDana = new Dictionary<string, int>();
   brojDana["januar"] = 31;
   brojDana["februar"] = 28;
   brojDana["mart"] = 31;
   ...

Речник, дакле, можемо схватити и као низ тј. листу у коме индекси нису
обавезно из неког целобројног интервала облика :math:`[0,n)`, већ могу
бити произвољног типа.

Проверу да ли је неком кључу придружена вредност у речнику можемо
остварити методом ``ContainsKey`` (она враћа ``true`` ако и само је
датом кључу придружена нека вредност). Уместо да прво проверавамо да је
вредност кључа присутна а затим да читамо вредност тог кључа, могуће је
користити метод ``TryGetValue`` који вредност чита само у једном
обиласку речника (уместо у два). На пример,

.. code:: csharp

   string mesec = Console.ReadLine();
   int broj;
   if (TryGetValue(mesec, out broj))
      Console.WriteLine("Broj dana: " + broj);
   else
      Console.WriteLine("Mesec nije korektno unet");

Све елементе речника могуће је исписати коришћењем петље ``foreach``. На
пример,

.. code:: csharp

   foreach (var x in brojDana)
        Console.WriteLine(x.Key + ": " + x.Value);

Редослед обиласка није лако унапред предвидети. Ако желимо да будемо
сигурни да ће се кључеви обилазити у сортираном редоследу, можемо уместо
``Dictionary`` употребити ``SortedDictionary``. Ова варијанта може бити
мало спорија него ``Dictionary``, али то је обично занемариво. Кључеви
сортиране мапе могу бити само они типови који се могу поредити (методом
``CompareTo``), док кључеви неуређене мапе могу бити само они типови
који се могу лако претворити у број (тзв. хеш-вредност) методом
``GetHashCode``. Ниске, које ћемо најчешће користити као кључеве,
задовољавају оба услова.

Покушај да решиш задатке са следеће странице коришћењем скупова и мапа.

.. comment

    - Дупликати
    - Двоструки студент
    - Неупарени елемент
    - Најбројнији елемент
    - Квадрати
    - Највећи поновљени елемент
    - Број различитих дужина дужи
    - Број парова датог збира
    - Тројке датог збира (3sum)
    - Провера пермутација
    - D-пермутација
