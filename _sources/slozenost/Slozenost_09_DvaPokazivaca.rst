Техника два показивача
======================

Угнежђене петље обично подразумевају постојање две бројачке променљиве
од којих спољашња само увећава своју вредност током итерације, док се
вредност бројачке петље у унутрашњој увећава до неке горње границе,
затим се поново враћа на неку доњу граници и поново увећава и то се
понавља више пута, све док спољашња бројачка променљива не достигне
своју максималну вредност. Ово по правилу доводи до квадратне сложености
(тј. сложености вишег степена у случају угнежђавања већег броја петљи).

Техника два показивача обухвата широку класу ефикасних алгоритама које
такође карактерише постојање две или више бројачких променљивих, које се
крећу кроз елементе неког низа (често сортираног). Међутим, оно што је
карактеристично за њих је то што се, за разлику од унутрашњих
променљивих у угнежђеним петљама, ове променљиве се стално “крећу у
истом смеру”, тј. вредност им се или стално повећава или стално смањује
(а честа је и комбинација где се “низ обилази са два краја”, где се
једна променљива стално повећава, а друга стално смањује). Техничка
реализација може бити било помоћу једне петље која контролише вредности
обе променљиве, било помоћу угнежђених петљи, али тако да се након
завршетка тела унутрашње петље, спољашња променљива увећава до места где
се унутрашња петља завршила. Пошто се свака променљива може променити
највише :math:`n` пута (где је :math:`n` неко горње ограничење њихове
вредности, обично дужина низа), број промена (па самим тим и извршавања
тела петље) је :math:`2n` и линеаран је по :math:`n` тј. сложеност му је
:math:`O(n)`.

Алгоритми засновани на техници два показивача обично могу да се изведу
коришћењем одсецања примењених на угнежђене петље, па је, као и код
сваке примене одсецања, потребно пажљиво образложити њихову коректност.

Пример: обједињавање два сортирана низа
---------------------------------------

Илуструјмо технику на примеру обједињавања два сортирана низа.

*Алгоритам обједињавања* (енгл. *merge*) подразумева да су низови који
се обједињавају сортирани. Због тога ће први елемент резултата бити мањи
од почетних елемената два низа (ако су једнаки, свеједно је који од њих
узети). Ако је један од низова празан, резултат обједињавања је други
низ и његове елементе је потребно једноставно прекопирати у резултат.
Ако низови нису празни, пошто су сортирани, први елемент низа је уједно
најмањи у њему. Мањи од два почетна елемента је мањи (или једнак) од
почетног елемента другог низа, па је мањи или једнак свим елементима у
оба низа и самим тим је најмањи елемент од свих и треба да буде први у
резултату. Када се тај елемент уклони из низа, добијамо проблем истог
типа као и полазни, који се онда решава на исти начин. Имплементација
може бити рекурзивна, међутим, рекурзија је репна и лако се елиминише.

Током итеративне имплементације одржавају се два показивача. Променљива
:math:`i` указује позицију текућег елемента првог и :math:`j` која
указује на текући елемент другог низа. Док су обе ове променљиве мање од
дужине низа по којем се крећу, поредимо елементе на тим позицијама. Ако
је елемент на позицији :math:`i` у првом низу мањи (или једнак) елементу
на позицији :math:`j` у другом низу, тада тај елемент преписујемо у
трећи низ (на позицију :math:`k` коју иницијализујемо на нулу и
увећавамо приликом додавања сваког новог елемента) и увећавамо :math:`i`
за 1. У супротном у трећи низ преписујемо елемент из другог низа са
позиције :math:`j` и увећавамо :math:`j`. Када бар једна од променљивих
достигне дужину одговарајућег низа, тада елементе преосталог низа
преписујемо у трећи низ. Не морамо експлицитно проверавати да ли у неком
од ових низова има преосталих елемената, већ можемо у једној петљи
копирати преостале елементе првог, а у другој петљи копирати преостале
елементе другог низа (једна од ових петљи ће бити празна).

Прикажимо рад овог алгоритма и на једном примеру.

-  Претпоставимо да је потребно објединити наредна два низа.

   ::

      a:          b:        c:
      0 1 2 3 4   0 1 2 3   0 1 2 3 4 5 6 7 8
      1 3 6 8 9   2 4 5 8   _ _ _ _ _ _ _ _ _
      i           j         k

-  У првом кораку је :math:`i=0` и :math:`j=0`, па се пореде елементи на
   позицијама 0, тј. елементи 1 и 2. Пошто је 1 мањи, он се преписује у
   резултујући низ и увећава се леви показивач.

   ::

      a:          b:        c:
      0 1 2 3 4   0 1 2 3   0 1 2 3 4 5 6 7 8
      1 3 6 8 9   2 4 5 8   1 _ _ _ _ _ _ _ _
        i         j           k

-  Сада је :math:`i=1` и :math:`j=0`, па се пореде елементи на
   позицијама 1 и 0, тј. 3 и 2. Пошто је 2 мањи, он се преписује у
   резултујући низ и увећава се десни показивач.

   ::

      a:          b:        c:
      0 1 2 3 4   0 1 2 3   0 1 2 3 4 5 6 7 8
      1 3 6 8 9   2 4 5 8   1 2 _ _ _ _ _ _ _
        i           j           k

-  Сада је :math:`i=1` и :math:`j=1`, па се пореде елементи на
   позицијама 1 и 1, тј. 3 и 4. Пошто је 3 мањи, он се преписује у
   резултујући низ и увећава се леви показивач.

   ::

      a:          b:        c:
      0 1 2 3 4   0 1 2 3   0 1 2 3 4 5 6 7 8
      1 3 6 8 9   2 4 5 8   1 2 3 _ _ _ _ _ _
          i         j             k

-  Сада је :math:`i=2` и :math:`j=1`, па се пореде елементи на
   позицијама 2 и 1, тј. 6 и 4. Пошто је 4 мањи, он се преписује у
   резултујући низ и увећава се десни показивач.

   ::

      a:          b:        c:
      0 1 2 3 4   0 1 2 3   0 1 2 3 4 5 6 7 8
      1 3 6 8 9   2 4 5 8   1 2 3 4 _ _ _ _ _
          i           j             k

-  Сада је :math:`i=2` и :math:`j=2`, па се пореде елементи на
   позицијама 2 и 2, тј. 6 и 5. Пошто је 5 мањи, он се преписује у
   резултујући низ и увећава се поново десни показивач.

   ::

      a:          b:        c:
      0 1 2 3 4   0 1 2 3   0 1 2 3 4 5 6 7 8
      1 3 6 8 9   2 4 5 8   1 2 3 4 5 _ _ _ _
          i             j             k

-  Сада је :math:`i=2` и :math:`j=3`, па се пореде елементи на
   позицијама 2 и 3, тј. 6 и 8. Пошто је 6 мањи, он се преписује у
   резултујући низ и увећава се леви показивач.

   ::

      a:          b:        c:
      0 1 2 3 4   0 1 2 3   0 1 2 3 4 5 6 7 8
      1 3 6 8 9   2 4 5 8   1 2 3 4 5 6 _ _ _
            i           j             k

-  Сада је :math:`i=3` и :math:`j=3`, па се пореде елементи на
   позицијама 3 и 3, тј. 8 и 8. Пошто су једнаки, било који од њих (на
   пример десни) може бити преписан у резултујући низ и одговарајући
   показивач се увећава.

   ::

      a:          b:        c:
      0 1 2 3 4   0 1 2 3   0 1 2 3 4 5 6 7 8
      1 3 6 8 9   2 4 5 8   1 2 3 4 5 6 8 _ _
            i             j               k

-  Пошто у другом низу више нема елемената, преостала два елемента левог
   низа (8 и 9) се преписују на крај резултата.

   ::

      a:          b:        c:
      0 1 2 3 4   0 1 2 3   0 1 2 3 4 5 6 7 8
      1 3 6 8 9   2 4 5 8   1 2 3 4 5 6 8 8 9
               i          j                   k

Имплементација може бити направљена на следећи начин.
               
.. code:: csharp
          
   using System;
    
   class Program
   {
       static int[] objedini(int[] a, int[] b)
       {
           int[] c = new int[a.Length + b.Length];
           int i = 0, j = 0, k = 0;
           while (i < a.Length && j < b.Length)
               c[k++] = a[i] < b[j] ? a[i++] : b[j++];
           while (i < a.Length)
               c[k++] = a[i++];
           while (j < b.Length)
               c[k++] = b[j++];
           return c;
       }
       
       static void Main()
       {
           // ucitavamo prvi niz
           int n = int.Parse(Console.ReadLine());
           string[] str = Console.ReadLine().Split();
           int[] a = new int[n];
           for (int i = 0; i < n; i++)
               a[i] = int.Parse(str[i]);
           
           // ucitavamo drugi niz
           int m = int.Parse(Console.ReadLine());
           str = Console.ReadLine().Split();
           int[] b = new int[m];
           for (int i = 0; i < m; i++)
               b[i] = int.Parse(str[i]);
    
           // objedinjavamo nizove i ispisujemo rezultat
           foreach (var x in objedini(a, b))
               Console.Write(x + " ");
           Console.WriteLine();
       }
   }

               
Покушај да коришћењем технике два показивача решиш задатке на 
следећој страници.

.. comment

    - Заједнички елементи три уређена низа
    - Близанци
    - Прости чиниоци 235
    - Тастатура и миш
    - Оптимални сервис
    - Двобојка
    - Тробојка
    - Број парова датог збира
    - Тројке датог збира (3sum)
    - Разлика висина
    - Сегмент датог збира у низу природних бројева
    - Пуно фигурица
    - Конференција
    - Најкраћа подниска која садржи све дате карактере
    - Број сегмената са различитим елементима
