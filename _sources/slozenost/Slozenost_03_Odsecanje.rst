Одсецање
========

Један од основних принципа за добијање ефикаснијих алгоритама и програма
је да рачунар не треба да израчунава ствари за које се унапред може
проценити да нису потребне за добијање коначног решења проблема. Важан
пример овог принципа се јавља код алгоритама претраге. Претрагу
елемената не треба експлицитно вршити међу елементима за које се може
унапред утврдити да не могу да задовоље услов претраге. Када прескочимо
проверу таквих елемената, кажемо да смо учинили **одсецање у претрази**.
Сличан принцип се примењује и када се врши оптимизација (тражи најмањи
односно највећи елемент), када се може прескочити анализа елемената за
које се унапред може доказати да су мањи (односно већи) од траженог
максимума (односно минимума).

Да би се осигурала коректност алгоритама у којима се врши одсецање увек
је потребно веома пажљиво утврдити да је одсецање оправдано и да се у
делу простора претраге који се не испитује заиста не може налазити
решење проблема.

У наставку овог поглавља ћемо кроз одређен број примера приказати како
се одсецањем постиже асимптотски ефикаснији алгоритам. Један од
најзначајнијих примера одсецања представља *бинарна претрага*, која ће,
због свог значаја бити анализирана у посебном поглављу. Одсецање се
примењује и у другим облицима претраге (бектрекинг претрази, претрази у
дубину, претрази у ширину), о чему ће више бити речи у каснијим
поглављима.

Испитивање да ли је број прост
------------------------------

Један од класичних примера одсецања у циљу добијања ефикаснијег
алгоритма јавља се у оквиру испитивања да ли је број прост.

Линеарна претрага свих потенцијалних делилаца
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Природан број је прост ако је већи од 1 и ако није дељив ни са једним
бројем осим са један и са самим собом. По дефиницији број 1 није
прост. Дакле, број већи од 1 је прост ако нема ни једног правог
делиоца. Потребно је дакле извршити претрагу скупа потенцијалних
делилаца и проверити да ли неки од њих стварно дели број :math`n`.

Скуп потенцијалних делилаца је скуп свих природних бројева од 2 до
:math:`n-1` и наивна имплементација их све проверава. Пошто се провера
сваког делиоца извршава израчунавањем једног остатка при дељењу,
сложеност овог приступа одговара броју делилаца и једнака је
:math:`O(n)`.

.. code:: csharp

   using System;

   class Program
   {
       static bool prost(int n)
       {
           if (n == 1) return false;
           for (int i = 2; i < n; i++)
               if (n % i == 0)
                   return false;
           return true;
       }
       
       static void Main()
       {
           int n = int.Parse(Console.ReadLine());
           Console.WriteLine(prost(n) ? "DA" : "NE");
       }
 
Одсецање у претрази
~~~~~~~~~~~~~~~~~~~

Делиоци броја се увек јављају у пару. На пример, делиоци броја 100
организовани по паровима су (1, 100), (2, 50), (4, 25) (5, 20) и (10,
10). Ако је :math:`i` делилац броја :math:`n`, делилац је и број
:math:`\frac{n}{i}`. При том, ако је :math:`i \geq \sqrt{n}`, тада је
:math:`\frac{n}{i} \leq \sqrt{n}`. Дакле, важи теорема која каже да број
има праве делиоце који су већи или једнаки вредности :math:`\sqrt{n}`
ако и само ако има делиоце који су мањи или једнак вредности
:math:`\sqrt{n}`. То нам даје могућност да претрагу потенцијалних
делилаца редукујемо само на интервал :math:`[2, \sqrt{n}]`, јер ако број
нема делилаца мањих или једнаких вредности :math:`\sqrt{n}`, онда не
може да има делилаца већих или једнаких тој вредности, тј. нема правих
делилаца и прост је. Обратите пажњу да је ово скраћивање интервала веома
значајно (ако је највећи број око :math:`10^9` тј. око милијарду, уместо
милијарду делилаца потребно је проверавати само њих корен из милијарду,
што је тек нешто изнад тридесет хиљада). Сложеност овог алгоритма је
:math:`O(\sqrt{n})`. Ово је пример алгоритма у ком је сложеност
поправљена тако што је елиминисан (одсечен) значајан део простора
претраге за који можемо да докажемо да га није неопходно проверавати.

Сама имплементација је једноставна и заснива се на алгоритму линеарне
претраге (који смо описали, на пример, у задатку ` <negativan_broj>`__).
У посебној функцији на почетку проверавамо специјалан случај броја 1
(ако је :math:`n` једнако 1, враћамо вредност ``false``). Након тога, у
петљи проверавамо потенцијалне делиоце од 2 до :math:`\sqrt{n}`. Један
начин да одредимо горњу границу је да употребимо библиотечку функцију
``sqrt`` тј. ``Math.Sqrt``. Међутим, рад са реалним бројевима је могуће
у потпуности избећи тако што се уместо услова :math:`i \leq \sqrt{n}`
употреби услов :math:`i\cdot i \leq n`. За сваку вредност :math:`i`
проверава се да ли је делилац броја :math:`i` (израчунавањем остатка при
дељењу). Чим се утврди да је :math:`i` делилац броја :math:`n` функција
може да врати ``false`` (тиме се уједно прекида извршавање петље). На
крају петље, функција може да врати ``true``, јер није пронађен ниједан
делилац мањи или једнак од :math:`\sqrt{n}`, па на основу теореме које
смо доказали не може постојати ни један делилац изнад те вредности и
број је прост.

.. code:: csharp

   using System;

   class Program
   {
       static bool prost(int n)
       {
           if (n == 1) return false;
           for (int i = 2; i*i <= n; i++)
               if (n % i == 0)
                   return false;
           return true;
       }
       
       static void Main()
       {
           int n = int.Parse(Console.ReadLine());
           Console.WriteLine(prost(n) ? "DA" : "NE");
       }
  }

Провера само парних бројева
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Још једна могућа оптимизација је да се на почетку провери да ли је
број паран а да се након тога проверавају само непарни делиоци (тако
се врши додатно одсецање), међутим, та оптимизација не доноси превише
(обилазак до корена је смањио број потенцијалних кандидата са милијарде
на тек тридесетак хиљада, а провера само парних делилаца тај број
смањује на петнаестак хиљада, што није значајна уштеда јер је већ и
провера 30000 вредности на данашњим рачунарима веома брза).

.. code:: csharp

   using System;
    
   class Program
   {
       // funkcija koja proverava da li je dati broj prost
       static bool prost(int n)
       {
           if (n == 1) return false;     // broj 1 nije prost
           if (n == 2) return true;      // broj 2 jeste prost
           if (n % 2 == 0) return false; // ostali parni brojevi nisu prosti
           // proveravamo neparne delioce od 3 do korena iz n
           for (int i = 3; i * i <= n; i += 2)
               if (n % i == 0)
                   return false;
           // nismo nasli delioca - broj jeste prost
           return true;
       }
       static void Main()
       {
           int n = int.Parse(Console.ReadLine());
           Console.WriteLine(prost(n) ? "DA" : "NE");
       }
   }          
  
Провера само бројева облика 6k-1 и 6к+1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Програм се још мало може убрзати ако се примети да су сви прости бројеви
већи од 2 и 3 облика :math:`6k-1` или :math:`6k+1`, за :math:`k \geq 1`
(наравно, обратно не важи). Заиста, бројеви облика :math:`6k`,
:math:`6k+2` и :math:`6k+4` су сигурно парни тј. дељиви са :math:`2`,
бројеви облика :math:`6k+3` су дељиви са :math:`3`, тако да су једини
преостали :math:`6k+1` и :math:`6k+5`, при чему су ови други сигурно
облика :math:`6k'-1` (за :math:`k' = k+1`). Дакле, уместо да проверавамо
дељивост са свим непарним бројевима мањим од корена, можемо проверавати
дељивост са свим бројевима облика :math:`6k-1` или :math:`6k+1`, чиме
избегавамо проверу са једним на свака три непарна броја и програм
убрзамо сходно томе.

.. code:: csharp

   using System;
    
   class Program
   {
       static bool prost(int n)
       {
           if (n == 1 ||
               (n % 2 == 0 && n != 2) ||
               (n % 3 == 0 && n != 3))
               return false;
           for (int k = 1; (6*k - 1) * (6*k - 1) <= n; k++)
               if (n % (6 * k + 1) == 0 || n % (6 * k - 1) == 0)
                   return false;
           return true;
       }
       
       static void Main()
       {
           int n = int.Parse(Console.ReadLine());
           Console.WriteLine(prost(n) ? "DA" : "NE");
       }
   }  

**Задаци:**

Уради сада задатке са следеће  стране. Напиши прво решења грубом силом,
првим алгоритмом који ти падне на памет, а затим покушај да употребиш
технику одсецања да дођеш до ефикаснијих решења.

.. comment

    -  Ератостеново сито
    -  Најдужа серија победа
    -  Серија сјајних партија
    -  Максимални збир сегмента
