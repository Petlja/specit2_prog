Едит растојање
==============

.. questionnote::

   Едит-растојање између две ниске се дефинише у терминима операција
   уметања, брисања и измена слова прве речи којима се може добити
   друга реч. Свака од ове три операције има своју цену. Дефинисати
   програм који израчунава најмању цену операција којима се од прве
   ниске може добити друга. На пример, ако је цена сваке операције
   јединична, тада се ниска `zdravo` може претворити у `bravo!`
   најефикасније операцијом измене слова `z` у `b`, брисања слова `d`
   и уметања карактера `!` или брисања слова `z`, изменом слова `d` у
   `b` и уметањем карактера `!`.

Изведимо прво индуктивно-рекурзивну конструкцију. 

- Ако је прва ниска празна, најефикаснији начин да се од ње добије
  друга ниска је да се уметне један по један карактер друге ниске,
  тако да је минимална цена једнака производу цене операције уметања и
  броја карактера друге ниске.

- Ако је друга ниска празна, најефикаснији начин да се од прве ниске
  добије празна је да се један по један њен карактер избрише, тако да
  је минимална цена једнака производу цене операције брисања и броја
  карактера прве ниске.

- Индуктивна хипотеза ће бити да умемо да решимо проблем за било
  која два префикса прве и друге ниске.

  - Ако су последња слова прве и друге ниске једнака, онда је потребно
    претворити префикс без последњег слова прве ниске у префикс без
    последњег слова друге ниске.

  - Ако нису, онда имамо три могућности.
    
    - Једна је да изменимо један од та два карактера у онај други и
      онда да, као у претходном случају, преведемо префиксе без
      последњих карактера један у други.

    - Друга могућност је да обришемо последњи карактер прве ниске и
      пробамо да претворимо тако њен добијени префикс у другу
      ниску.

    - Трећа могућност је да прву ниску трансформишемо у префикс
      друге ниске без последњег карактера и да затим додамо последњи
      карактер друге ниске.
    
На основу овога лако можемо дефинисати рекурзивну функцију која
израчунава едит-растојање. Да нам се ниске не би мењале током
рекурзије (што може бити споро), ефикасније је да ниске прослеђујемо у
неизмењеном облику и да само прослеђујемо бројеве карактера њихових
префикса који се тренутно разматрају.

.. code-block:: csharp

    static int editRastojanje(string s1, string s2, int n1, int n2)
    {
        if (n1 == 0)
            return n2 * cenaUmetanja;
        if (n2 == 0)
            return n1 * cenaBrisanja;
        if (s1[n1-1] == s2[n2-1])
            return editRastojanje(s1, s2, n1-1, n2-1);
        int r1 = editRastojanje(s1, s2, n1-1, n2) + cenaUmetanja;
        int r2 = editRastojanje(s1, s2, n1, n2-1) + cenaBrisanja;
        int r3 = editRastojanje(s1, s2, n1-1, n2-1) + cenaIzmene;
        return Math.Min(Math.Min(r1, r2), r3);
    }
    
    static int editRastojanje(string s1, string s2)
    {
        int n1 = s1.Length, n2 = s2.Length;
        return editRastojanje(s1, s2, n1, n2);
    }

Током извршавања ове функције многи рекурзивни позиви се извршавају
пуно пута, па је ова имплементација врло неефикасна. Примени технику
динамичког програмирања да је убрзаш. Пошто се током рекурзије мењају
два целобројна параметра (саме ниске се не мењају), резултате
рекурзивних позива уместо у низу можеш памтити у матрици. На сајту
Математичког факултета Универзитета у Београду можеш наћи `апликацију
<http://www.matf.bg.ac.rs/~filip/algoritmi/dp/edit-rastojanje.html>`__ која ће
ти помоћи да разумеш како се овај проблем решава техником динамичког
програмирања. Примети како се матрица попуњава ред по ред и како
наредни ред зависи само од претходног, што ти омогућава да задатак
решиш у меморијског сложености :math:`O(n)` (док временска сложеност
остаје :math:`O(n^2)`). Своје решење можеш испробати у наредном
`такмичењу на Петљи
<https://arena.petlja.org/competition/dp-rg2020-korona#tab_130153>`_.

