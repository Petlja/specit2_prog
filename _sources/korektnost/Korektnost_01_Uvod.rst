Коректност алгоритама и програма
================================

*Делови текста у наставку су преузети из скрипте “Програмирање 2”, аутора
Предрага Јаничића и Филипа Марића*.

Исправност тј. коректност је суштинска особина алгоритама и програма.
Иако се некада у пракси користе програми за које се зна да понекад могу
да дају и нетачне резултате, то најчешће није случај и од програма се
захтева да буде практично апсолутно непогрешив.

Једно од централних питања у развоју програма је питање његове
исправности (коректности). Софтвер је у данашњем свету присутан на
сваком кораку: софтвер контролише много тога — од банковних рачуна и
компоненти телевизора и аутомобила, до нуклеарних електрана, авиона и
свемирских летелица. У свом том софтверу неминовно су присутне и грешке.
Грешка у функционисању даљинског управљача за телевизор може бити тек
узнемирујућа, али грешка у функционисању нуклеарне електране може имати
разорне последице. Најопасније грешке су оне које могу да доведу до
великих трошкова, или још горе, до губитка људских живота. Неке од
катастрофа које су општепознате су експлозија ракете Ариане 1996.
узрокована конверзијом броја из шездесетчетворобитног реалног у
шеснаестобитни целобројни запис која је довела до прекорачења, затим пад
сателита Криосат (енгл. Cryosat) 2005. године услед грешке у софтверу
због које није на време дошло до раздвајања сателита и ракете која га је
носила коштао је Европску Унију око 135 милиона евра, затим грешка у
нумеричком копроцесору процесора Pentium 1994. узрокована погрешним
индексима у петљи ``for`` у оквиру софтвера који је радио дизајн чипа,
као и пад орбитера послатог на Марс 1999. узрокован чињеницом да је део
софтвера користио метричке, а део софтвера енглеске јединице. Међутим,
фаталне софтверске грешке и даље се непрестано јављају и оне коштају
светску економију милијарде долара. Ево неких од најзанимљивијих:

-  Не нарочито опасан, али веома занимљив пример грешке је грешка у
   програму Microsoft Excel 2007 који, због грешке у алгоритму
   форматирања бројева пре приказивања, резултат израчунавања израза
   ``77.1 * 850`` приказује као ``100 000`` (иако је интерно коректно
   сачуван).

-  У Лос Анђелесу је 14. септембра 2004. године више од четиристо авиона
   у близини аеродрома истовремено изгубило везу са контролом лета. На
   срећу, захваљујући резервној опреми унутар самих авиона, до несреће
   ипак није дошло. Узрок губитка везе била је грешка прекорачења у
   бројачу милисекунди у оквиру система за комуникацију са авионима. Да
   иронија буде већа, ова грешка је била откривена раније, али пошто је
   до открића дошло када је већ систем био испоручен и инсталиран на
   неколико аеродрома, његова једноставна поправка и замена није била
   могућа. Уместо тога, препоручено је да се систем ресетује сваких 30
   дана како до прекорачења не би дошло. Процедура није испоштована и
   грешка се јавила после тачно :math:`2^{32}` милисекунди, односно 49,7
   дана од укључивања система.

-  Више од пет процената пензионера и прималаца социјалне помоћи у
   Немачкој је привремено остало без свог новца када је 2005. године
   уведен нови рачунарски систем. Грешка је настала због тога што је
   систем, који је захтевао десетоцифрени запис свих бројева рачуна, код
   старијих рачуна који су имали осам или девет цифара бројеве допуњавао
   нулама, али са десне уместо са леве стране како је требало.

-  Једна бака у Америци је на свој 106. рођендан добила позив да мора да
   крене у школу, јер је систем бележио године помоћу две цифре.

-  Компаније Dell и Apple морале су током 2006. године да корисницима
   замене више од пет милиона лаптоп рачунара због грешке у дизајну
   батерије компаније Sony која је узроковала да се неколико рачунара
   запали.

Облици испитивања коректности
-----------------------------

Поступак показивања да је програм исправан назива се **верификовање
програма**. У развијању техника верификације програма, потребно је
најпре прецизно формулисати појам исправности програма. Исправност
програма почива на појму спецификације. Спецификација је, неформално,
опис жељеног понашања програма који треба написати. Спецификација се
обично задаје у терминима **предуслова** тј. услова које улазни
параметри програма задовољавају, као и **постуслова** тј. услова које
резултати израчунавања морају да задовоље. Када је позната
спецификација, потребно је верификовати програм, тј. доказати да он
задовољава спецификацију. Два основна приступа верификацији су:

**динамичка верификација**
   подразумева проверу исправности у фази извршавања програма, најчешће
   путем тестирања;

**статичка верификација**
   подразумева анализу изворног кода програма, често коришћењем
   формалних метода и математичког апарата.

Систематично тестирање је сигурно најзначајнији облик постизања високог
степена исправности програма. Тестирањем на већем броју исправних улаза
и упоређивањем добијених и очекиваних резултата може се открити велики
број грешака. Нагласимо и да се тестирањем не може показати да је
програм коректан, већ само да није коректан. Наиме, практично никада
није могуће испитати понашање програма баш на свим исправним улазима.
Већ програм који сабира два 32-битна броја има
:math:`2^{32}\cdot 2^{32} = 2^{64}` исправних комбинација улазних
параметара и исцрпно тестирање оваквог програма би трајало годинама.
Зато се исцрпно тестирање скоро никада не спроводи, већ се програми
тестирају тако да се улази бирају пажљиво, тако да покрију различите
гране током извршавања програма. Обично се додатно посебно тестира
понашање програма на неким граничним улазима (енгл. edge cases, corner
cases), јер програми понекада не обрађују све специјалне случајеве како
би требало. Многи системи за учење програмирања (такозвани грејдери,
енгл. grader) оцењују ученичка решења тестирањем на већем броју
тест-примера и савет почетницима је да током учења обавезно користе
овакве системе.

О методама статичке верификације биће више речи у наставку овог
поглавља.

Коректност се огледа кроз два аспекта:

**парцијална коректност**
   свака вредност коју алгоритам израчуна за улазне параметре који
   задовољавају спецификацију (тј. предуслов) мора да задовољи
   спецификацију (тј. подуслов).

**заустављање**
   алгоритам мора да се заустави за све улазе који задовољавају
   спецификацију (тј. предуслов).

Већина алгоритама које ћемо проучавати у овом курсу биће потпуни тј.
заустављаће се за све допуштене улазе. За заустављајуће парцијално
коректне алгоритме кажемо да су **тотално коректни**. Интересантно,
доказано је да не постоје алгоритми којима би се испитивала горе
наведена својства алгоритама.

Неке честе грешке при прављењу програма
---------------------------------------

Сваки исправан програм мора да буде заснован на исправном алгоритму.
Дакле, од неисправног алгоритма није могуће направити исправан програм и
основна ствар приликом писања исправних програма је да се обезбеди
исправност алгоритма који се примењује. Са друге стране, алгоритми се
описују често на апстрактнијем нивоу него што су сами програми, и многи
детаљи се занемарују. Зато се услед детаља имплементације од исправног
алгоритма може добити неисправан програм. 

Грешке у програмима често настају и због лоше комуникације. На пример, 
задатак није довољно прецизно постављен, па онај ко захтева програм и 
онај ко га пише немају на уму исти задатак. Слична је ситуација и при 
недовољно пажљивом читању спецификације, односно поставке задатка, где
може доћи до погрешног разумевања задатка. Још неке честе грешке су:

-  Грешка погрешног избора типа. Она настаје када се при писању програма
   одабере бројевни тип података којим се не могу исправно представити сви
   подаци, међурезултати и резултати. Тада при покушају уписивања неке 
   вредности у предвиђени простор долази до **прекорачења** (енгл.
   overflow) и програм даје неисправне резултате. Посебно је осетљив случај 
   када програмер одабере тип података који може исправно да репрезентује 
   и улазне и излазне вредности, али не и све међурезултате. Такву грешку 
   је теже приметити, а она доводи до истог проблема и неисправног резултата.

-  Грешка за 1 (енгл. off by one). Типично питање код кога се чини ова 
   грешка је: "Стубови који носе ограду се постављају на свака два метра. 
   Ако је ограда дуга 20 метара, колико има стубова?" Тачан одговор је 11, 
   а не 10, као што би брзоплето могло да се закључи. Сличних питања има
   још, нпр. "ако од дуже даске треба исећи пет краћих, на колико места 
   треба сећи?" (одговор је 4). У програмерском контексту: "Потребно је 
   обрадити елементе низа почев од индекса *a*, закључно са индексом *b*. 
   Колико је то елемената укупно?" (тачан одговор је *b-a+1*).

   Грешке за 1 лако доводе до **прекорачења граница низа** (енгл. buffer 
   overflow). На пример, ако смо у низу одвојили место за 30 бројева, онда је
   могуће уписивати вредности само на позиције :math:`0`, :math:`1`,
   :math:`\ldots`, :math:`29`. Нарочито је критична позиција :math:`30`
   (тј. у општем случају позиција :math:`n` за низ од :math:`n`
   елемената). Пошто у савременим програмским језицима бројање позиција
   у низовима креће од нуле, на позицију :math:`n` није могуће уписивати
   вредности. У језику C++ се не врши провера опсега пре приступа
   елементима низа (тј. вектора) и одговорност је програмера да обезбеди
   да се не приступа ван граница - у супротном је понашање програма
   недефинисано, што значи да програм може да настави да ради неисправно
   и после одређеног броја инструкција да буде прекинут од стране
   оперативног система, али и да грешка може да прође неопажено. Језик
   C# врши проверу опсега при сваком приступању елементима низа и ако се
   приступ врши ван граница низа, програм аутоматски подиже
   изузетак (ако се на њега не одреагује у програму, ово доводи до
   прекида програма). Уколико у петљи у низ уписујемо податке чији број
   не знамо унапред, може бити потребно да пре сваког уписа проверимо да ли се
   упис врши унутар граница низа (или да користимо неки облик низа који
   допушта аутоматско проширивање додавањем нових елемената).

-  Грешке приликом копирања. Често су нам у програмима потребне две или више 
   врло сличних наредби (или група наредби). Уобичајено је да се у таквој
   ситуацији одређене наредбе копирају а затим преправе. Приликом преправљања 
   се често заборавља неки детаљ, што је веома чест пропуст. Такве грешке могу 
   да се манифестују на различите начине, зависно од тога шта смо заборавили 
   да преправимо.

-  Грешка необраћања пажње на **специјалне случајеве**. На
   пример, ако у низу тражимо елемент који задовољава неки услов,
   неопходно је да обезбедимо да програм коректно ради и у случају када
   ниједан елемент не задовољава тај услов. Треба пажљиво прецизирати да
   ли функција тада треба да врати број елемената низа или, на пример,
   -1, и треба осигурати да се у коду који позива ову функционалност
   добро реагује на ситуацију у којој тражени елемент не постоји.
   Специјални случајеви најчешће настају када неке вредности не постоје
   (када је неки скуп чије елементе разматрамо празан), затим када су
   улазне вредности у неком специјалном односу (на пример, да ли
   геометријски програм исправно ради ако су унете тачке колинеарне) и
   слично. При том, треба пажљиво прецизирати спецификацију задатка и
   одредити који специјални случајеви јесу, а који нису допуштени
   спецификацијом. И овде треба обратити пажњу на то да иако
   улазни параметри можда не могу бити у неком специјалном односу, 
   међурезултати можда могу, па је онда потребно
   програме ипак прилагодити тако да обраде и специјалне случајеве.

