Пример: најмањи број који није збир подскупа
============================================

Дат је скуп природних бројева (задат у облику сортираног низа). Одредити
најмањи природан број који није збир неких елемената тог скупа.

Улаз
----

Са стандардног улаза се учитава број :math:`n`
(:math:`1 \leq n \leq 10^3`), а затим у наредном реду сортиран низ од
:math:`n` различитих природних бројева мањих од :math:`10^4`.

Излаз
-----

На стандардни излаз исписати тражени најмањи природан број који није
збир неких елемената тог скупа.

Пример
------

Улаз
~~~~

::

   8
   1 2 4 7 15 32 35 48

Излаз
~~~~~

::

   30

Решење
------

Чињеница да су елементи сортирани олакшава решење задатка. Обрађиваћемо
елемент по елемент и одржаваћемо границу до које смо сигурни да се сваки
број може представити као збир неког подскупа. Можда мало изненађујуће,
та граница је у сваком кораку једнака збиру свих тренутно учитаних
елемената. Ако је нови учитани елемент строго већи од збира свих
претходних елемената увећаног за један, онда се тај увећани збир не може
добити као подскуп. У супротном можемо бити сигурни да се сви бројеви од
0 па до збира свих елемената (у који је укључен и нови елемент) могу
добити као збир неког подскупа. Наиме, пошто је у претходном кораку било
могуће добити све бројеве од 1 до збира свих елемената без тог новог,
када у све те подскупове укључимо нови елемент добићемо све бројеве од
тог новог елемента, па до збира свих елемената са тим новим елементом.

На пример, нека је дат низ :math:`1, 2, 3, 5, 14, 20, 27`.

-  0 можемо добити као збир празног скупа :math:`\{\}`.
-  1 можемо добити као збир скупа :math:`\{1\}`.
-  Када у претходне скупове укључимо и :math:`2`, можемо добити све
   бројеве закључно са :math:`3` (:math:`2` као :math:`\{2\}` и
   :math:`3` као :math:`\{1, 2\}`).
-  Када у претходне скупове укључимо и :math:`3`, можемо добити све
   бројеве закључно са :math:`6` (:math:`4` као :math:`\{1, 3\}`,
   :math:`5` као :math:`\{2, 3\}`\ $ и :math:`6` као
   :math:`\{1, 2, 3\}`).
-  Када у претходне скупове укључимо :math:`5` можемо добити све бројеве
   закључно са :math:`11` (:math:`7` као :math:`\{2, 5\}`, :math:`8` као
   :math:`\{1, 2, 5\}`\ $ и :math:`9` као :math:`\{1, 3, 5\}`,
   :math:`10` kao :math:`\{2, 3, 5\}` и :math:`11` као
   :math:`\{1, 2, 3, 5\}`).
-  Пошто је наредни број :math:`14`, јасно је да се број :math:`12` не
   може никако добити.

Решење се може имплементирати на следећи начин.
   
.. code:: csharp
          
   using System;
    
   class Program
   {
       static void Main(string[] args)
       {
           int n = int.Parse(Console.ReadLine());
           // sabiranjem elemenata trenutnog sukpa mogu se dobiti svi elementi
           // iz intervala [0, mozeDo]
           int mozeDo = 0;
           string[] str = Console.ReadLine().Split();
           for (int i = 0; i < n; i++) {
               int x = int.Parse(str[i]);
               if (x > mozeDo + 1)
                   break;
               mozeDo += x;
           }
           Console.WriteLine(mozeDo + 1);
       }
   }

   
Докажимо и формално коректност, овог алгоритма тј. претходног програма.

**Лема:** Нека је :math:`m` вредност променљиве ``mozeDo``. Инваријанта
петље је да је :math:`0 \leq i \leq n`, да је :math:`m` збир првих
:math:`i` елемената низа и да се сваки број из интервала :math:`[0, m]`
може добити као збир неког подскупа првих :math:`i` елемената низа.

Пре уласка у петљу је :math:`i=0` и :math:`m=0`. Збир првих :math:`i=0`
елемената низа је по дефиницији нула (тј. :math:`m`). Број :math:`0` је
једини елемент интервала :math:`[0, m] = [0, 0]` и он се може добити као
збир празног подскупа (тј. 0 елемената полазног низа).

Претпоставимо да тврђење важи пре уласка у петљу.

-  Ако је :math:`a_i > m+1`, тврдимо да је :math:`m+1` тражени најмањи
   број. На основу инваријанте знамо да су сви бројеви из интервала
   :math:`[0, m]` покривени, тако да мањи број од :math:`m+1` не може
   бити решење. Докажимо да број :math:`m+1` не може бити збир подскупа.
   Пошто је низ сортиран, сви елементи од :math:`a_i` до :math:`a_{n-1}`
   су строго већи од :math:`m+1`. Дакле, ни један од тих елемената не
   сме бити укључен у подскуп јер би њиховим укључивањем збир већ
   премашио :math:`m+1`. Подскуп се мора састојати само од елемената
   :math:`a_0` до :math:`a_{i-1}`, међутим, пошто је :math:`m` њихов
   збир, збир сваког њиховог подскупа је мањи или једнак :math:`m`.
   Дакле, :math:`m+1` се не може постићи и он је тражено решење.

-  Ако је :math:`a_i \leq m+1`, тада је :math:`m' = m + a_i`,
   :math:`i' = i + 1` и тврдимо да је :math:`m'` збир свих елемената
   :math:`а_0`, …, :math:`а_i` и да се сваки број из интервала
   :math:`[0, m']` може представити као збир неког подскупа првих
   :math:`i' = i+1` елемената низа. Прва тврдња је прилично очигледна,
   јер је по претпоставци :math:`m` збир свих елемената :math:`a_0`, …,
   :math:`a_{i-1}`, а :math:`m' = m+a_i`. На основу претпоставке знамо
   да сви бројеви из :math:`[o, m]` могу бити збирови подскупова првих
   :math:`i` елемената низа. Слично и сви бројеви из интервала
   :math:`[a_i, a_i + m]` се могу добити као збир неког подскупа првих
   :math:`i' = i+1` елемента низа. Наиме, тај подскуп ће бити унија
   елемента :math:`a_i` и оног подскупа првих :math:`i` елемената низа
   чији је збир једнак разлици између тог броја и броја :math:`a_i` – он
   је из :math:`[0, m]`, па на основу претпоставке такав подскуп
   постоји. Пошто је :math:`a_i \leq m + 1` унија интервала
   :math:`[0, m]` и :math:`[a_i, a_i+m]` је
   :math:`[0, a_i+m] = [0, m']`. Зато је сваки елемент из
   :math:`[0, m']` једнак збиру неког подскупа првих :math:`i'`
   елемената низа, па инваријанта остаје очувана.

**Теорема:** Случај када се петља заврши прекидом, јер је
:math:`a_i > m+1` је већ размотрен. Када се петља заврши, важи да је
:math:`i = n`. На основу инваријанте :math:`m` је збир свих елемената
низа, и сваки број из :math:`[0, m]` јесте збир неког подскупа првих
:math:`i=n` елемената низа, тј. целог низа. Зато је :math:`m+1` најмањи
елемент који није могуће добити (јер се укључивањем свих елемената
добија највише :math:`m`) и исписано решење је исправно.

