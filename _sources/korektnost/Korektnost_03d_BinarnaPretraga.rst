Пример: бинарна претрага преломне тачке
=======================================

:math:`\newcommand{\floor}[1]{\left\lfloor{#1}\right\rfloor}`

**Задатак:** Размотримо низ бројева :math:`210, 2310, 390, 30, 510, 66,
6, 138, 46, 106, 59, 17, 23`. Он је интересантан из неколико
разлога. На пример, првих пет бројева је дељиво са 10, а после ниједан
број није дељив са 10. Првих десет бројева је парно, а после су сви
бројеви непарни. Првих осам бројева је дељиво са 6, а после ниједан
број није дељив са 6. Прва два броја су дељива са 210, а после ниједан
број није дељив са 210, итд. Покушај да пронађеш још оваквих
правилности. Напиши програм који за сваки унети делилац за који
сигурно важи оваква правилност одређује колико бројева је дељиво са
њим.

Улаз
----

Са стандардног улаза се учитава број :math:`n`
(:math:`1 \leq n \leq 10^5`), а затим у наредном реду :math:`n`
природних бројева (мањих од :math:`10^18`) раздвојених са по једним
размаком. Након тога се до краја улаза уносе делиоци (сваки у посебном
реду) за које се сигурно зна да је низ такав да прво иду бројеви који
јесу, а затим бројеви који нису дељиви са њима.

Излаз
-----

За сваки унети делилац у посебном реду исписати број елемената низа који
су њиме дељиви.

Пример
------

Улаз
~~~~

::

   13
   210 2310 390 30 510 66 6 138 46 106 59 17 23
   10
   2
   6
   2
   4
   15

Излаз
~~~~~

::

   5
   10
   8
   10
   0
   5

Бинарна претрага
----------------

Захваљујући интересантној особини низа, задатак ефикасно може бити решен
применом алгоритма бинарне претраге. У питању је варијанта алгоритма
бинарне претраге у ком се уместо позиције конкретне вредности у
сортираном низу захтева проналажење прве позиције на којој се налази
елемент који задовољава неки услов. Наиме, под претпоставком да се у
низу прво налазе елементи који не задовољавају тај услов, а затим
елементи који задовољавају тај услов, *преломну тачку* (тренутак када се
из једне прелази у другу групу елемената) можемо наћи бинарном
претрагом. Дакле, ако је низ облика ``-------+++++++``, бинарном
претрагом можемо пронаћи позицију последњег минуса, првог плуса, број
минуса тј. број плусева, где смо са ``-`` означили оне елементе који не
задовољавају, а са ``+`` оне елементе који задовољавају дати услов.

Ручно имплементирана бинарна претрага
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Током рада алгоритма, одржавамо две променљиве :math:`l` и :math:`d`
такве да важи инваријанта да је :math:`0 \leq l \leq d+1 \leq n` и да су

-  лево од :math:`l` тј. у интервалу позиција :math:`[0, l)` елементи
   који не задовољавају услов,

-  десно од :math:`d` тј. у интервалу позиција :math:`(d, n)` елементи
   који задовољавају услов.

У интервалу позиција :math:`[l, d]` налазе се елементи чији статус још
није познат. На почетку су сви елементи непознати, па је јасно да
интервал :math:`[l, d]` треба иницијализовати на :math:`[0, n-1]`, тј.
променљиву :math:`l` треба иницијализовати на нулу, а :math:`d` на
вредност :math:`n-1`. Интервали :math:`[0, l)` и :math:`(d, n)` су
празни, па је инваријанта очувана (услов :math:`l \leq d+1` се своди на
:math:`0 \leq n`, што је тривијално испуњено).

Ако интервал позиција :math:`[l, d]` није празан тј. ако је :math:`l
\leq d`, проналазимо му средину :math:`s = l +
\floor{\frac{d-l}{2}}`. Пошто је :math:`l \leq d`, важи и да је
:math:`l \leq s \leq d`.

-  Ако елемент на позицији :math:`s` задовољава услов, тада на основу
   монотоности услов задовољавају и сви елементи десно од :math:`s`.
   Зато померамо :math:`d` за једно место лево од средине тј. вредност
   променљиве :math:`d` постављамо на :math:`s-1` (нове вредности
   променљивих су :math:`l'=l` и :math:`d' = s-1`). Тиме инваријанта
   остаје на снази (посебно, сви елементи у интервалу позиција
   :math:`(s-1, n) = [s, n)` задовољавају услов). Важи и услов
   :math:`0 \leq l' \leq d'+1 \leq n`, јер је он еквивалентан услову
   :math:`0 \leq l \leq s \leq n`.

-  Ако елемент на позицији :math:`s` не задовољава услов, тада на основу
   монотоности услов не задовољавају ни сви елементи лево од :math:`s`.
   Зато померамо :math:`l` за једно место десно од средине тј. вредност
   променљиве :math:`l` постављамо на :math:`s+1` (нове вредности
   променљивих су :math:`l'=s+1` и :math:`d'=d`). Тиме инваријанта
   остаје одржана (посебно, ниједан елемент у интервалу позиција
   :math:`(0, l) = [0, s]` не задовољава услов). Важи и услов
   :math:`0 \leq l' \leq d'+1 \leq n` који је еквивалентан услову
   :math:`0 \leq s+1 \leq d+1 \leq n`.

Претрага траје све док се интервал :math:`[l, d]` не испразни, тј. док
је :math:`l \leq d`. Када се интервал испразни, тада је :math:`l > d`,
па пошто важи :math:`0 \leq l \leq d+1 \leq n`, важи и :math:`l = d+1`.
На основу инваријанте знамо да су елементи који задовољавају услов на
позицијама :math:`(d, n) = [l, n]`. Зато је први елемент који задовољава
услов је на позицији :math:`l` (што је уједно и број елемената који не
задовољавају услов). Елементи који не задовољавају услов су на
позицијама :math:`[0, l) = [0, d+1) = [0, d]`, па је последњи елемент
који не задовољава на позицији :math:`d`.

Заустављање се лако доказује тако што се доказује да се у сваком кораку
петље интервал :math:`[l, d]` тј. његова дужина :math:`d - l + 1`
смањује, што је прилично очигледно и када је :math:`l'=l` и
:math:`d'=s-1 < d` и када је :math:`l < l'=s+1` и :math:`d'=d`.

.. code:: csharp

   using System;
    
   class Program
   {
       static void Main()
       {
           int n = int.Parse(Console.ReadLine());
           long[] a = new long[n];
           string[] str = Console.ReadLine().Split();
           for (int i = 0; i < n; i++)
               a[i] = long.Parse(str[i]);
           string linija;
           while ((linija = Console.ReadLine()) != null)
           {
               long d = long.Parse(linija);
               int levo = 0, desno = n-1;
               while (levo <= desno) {
                   int sredina = levo + (desno - levo) / 2;
                   if (a[sredina] % d != 0)
                       desno = sredina - 1;
                   else
                       levo = sredina + 1;
               }
               Console.WriteLine(levo);
           }
       }
   }

      
Исправљање грешака на основу формалне анализе кода
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Када је кôд коректан, доказ је обично неинформативан. Помаже нам да
“мирно спавамо”, али ништа више од тога. Много интересантнија ситуација
се дешава у случају када нам формално резоновање о коду помаже да
детектујемо и исправимо грешке у програму (тзв. багове). Погледајмо
наредни покушај имплементације алгоритма.

.. code:: csharp

     int l = 0, d = n;
     while (l < d)
     {
       int s = l + (d - l) / 2;
       if (a[s] % 2 == 0)
         d = s-1;
       else
         l = s+1;
     }
     Console.WriteLine(d+1);

На основу инцијализације делује да покушавамо да претражимо
полузатворени интервал :math:`[l, d)`. Пошто је у питању бинарна
претрага, изгледа да се намеће инваријанта да је
:math:`0 \leq l \leq d \leq n` и да су:

-  сви елементи из :math:`[0, l)` непарни,

-  сви из интервала :math:`[d, n)` парни.

На почетку су оба та интервала празна, па инваријанта за сада добро
функционише. Ако погледамо услов петље, делује да петља ради док се
интервал непознатих елемената :math:`[l, d)` не испразни (заиста, када
је :math:`l \geq d`, тај интервал је празан). За сада све ради како
треба. Покушамо сада да проверимо да ли извршавање тела петље одржава
инваријанту.

-  Ако је :math:`a_s` паран елемент, тада се променљива ``d`` поставља
   на вредност :math:`d' = s-1`. На основу инваријанте треба да важи да
   су сви елементи у интервалу :math:`[d', n)` парни. Међутим, ми то не
   знамо, јер само знамо да је :math:`a_s` паран, али не знамо да је
   :math:`a_{s-1}` паран. Дакле, овде се сигурно крије грешка у коду.
   Ако доделу ``d = s-1`` заменимо са ``d = s``, тада ће инваријанта
   бити одржана (јер знамо да је паран :math:`a_s`, па ће бити парни и
   сви елементи иза њега).

-  Ако је :math:`a_s` непаран, тада се променљива ``l`` поставља на
   вредност :math:`l' = s+1`. На основу инваријанте треба да важи да су
   сви елементи у интервалу :math:`[0, l')` непарни, међутим, то ће овде
   бити испуњено, јер је :math:`a_s` непарно, па су непарни и сви
   елементи испред њега. Дакле, у овом случају је кôд коректан и
   инваријанта остаје одржана.

На крају, када се петља заврши можемо закључити да важи да је
:math:`l = d` (јер све време важи да је :math:`l \leq d`, а након петље
не важи да је :math:`l < d`). У коду се за позицију првог парног
елемента проглашава позиција :math:`d+1`. Иако је у оригиналној
варијанти кода ``l`` могло без проблема да се замени са ``d+1``, у овој
варијанти то није могуће. Наиме, ми на основу инваријанте овог кода
знамо да се на позицији :math:`l = d` налази паран елемент, а да се на
позицији :math:`l-1` налази непаран (осим када је :math:`l = 0` и тада
непарних елемената нема). Зато крајњи резултат није коректан и потребно
га је заменити са ``d``, јер се први парни елемент налази на позицији
:math:`d` (осим када су сви непарни, када је :math:`d=n`, но и тада је
:math:`d` исправна повратна вредност). Дакле, открили смо и исправили
две грешке.

Програмери често програм исправљају тако што насумице покушавају да
помере индексе за 1 лево или десно, да замене мање са мање или једнако и
слично. Већ на овако кратким програмима се види да је простор могућих
комбинација велики, а да је могућност за грешку приликом таквог
експерименталног приступа веома велика. Стога је увек боље застати,
формално анализирати шта је потребно да кôд ради и исправити га на
основу резултата формалне анализе.

На крају, скренимо пажњу на још један детаљ исправљеног програма.
Парцијална коректност је јасна на основу анализе коју смо спровели,
међутим, заустављање може бити доведено у питање, с обзиром на наредбу
``d = s``. Заустављање доказујемо тако што показујемо да се у сваком
корају смањује број непознатих елемената, тј. да дужина интервала
:math:`[l, d)` која је једнака :math:`d-l` у сваком кораку петље опада.
Пошто је :math:`l \leq d` инваријанта, смањивање не може трајати довека,
па се у неком тренутку програм зауставља. Поставља се питање да ли се
:math:`d-l` смањује и у измењеном коду у коме се јавља наредба ``d=s``.
Одговор је потрврдан, а образложење је суптилно. Прво, на основу услова
петље важи да је :math:`l < d`. Даље, вредност :math:`s` се израчунава
наредбом ``s = l + (d - l) / 2`` што нам да је
:math:`s = \floor{\frac{l + d}{2}}`. Због заокруживања наниже, важи да
је :math:`s < d` и зато се након одређивања :math:`d' = s`,
:math:`l' = l` вредност :math:`d' - l'` смањује у односу на
:math:`d - l`. Важи и да је :math:`l \leq s`, али пошто је у другој
грани :math:`l' = s+1` и :math:`d' = d`, вредност :math:`d' - l'` се
опет смањује у односу на :math:`d-l`. Да је заокруживање којим случајем
вршено навише (нпр. ``s = l + (d - l + 1) / 2``), програм би могао
упасти у бесконачну петљу.

.. code:: csharp

   using System;
    
   class Program
   {
       static void Main()
       {
           int n = int.Parse(Console.ReadLine());
           long[] a = new long[n];
           string[] str = Console.ReadLine().Split();
           for (int i = 0; i < n; i++)
               a[i] = long.Parse(str[i]);
           string linija;
           while ((linija = Console.ReadLine()) != null)
           {
               long d = long.Parse(linija);
               int levo = 0, desno = n;
               while (levo < desno) {
                   int sredina = levo + (desno - levo) / 2;
                   if (a[sredina] % d != 0)
                       desno = sredina;
                   else
                       levo = sredina + 1;
               }
               Console.WriteLine(desno);
           }
       }
   }
