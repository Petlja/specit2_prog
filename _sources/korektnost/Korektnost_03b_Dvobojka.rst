Пример: двобојка - парни, па непарни
====================================

Напиши програм који организује елементе низа тако да прво иду сви парни
елементи, а затим непарни, при чему међусобни редослед парних и непарних
елемената није битан. Елементе прво учитати у низ, а затим тај низ
трансформисати у линеарном времену (само једним пролазом кроз низ).

Улаз
----

У првој линији стандардног улаза унети природан број :math:`n`
(:math:`1\le n \le 50000`) - број елемената низа, а у наредној линија
унети :math:`n` природних бројева у границама од :math:`1` до :math:`1000`.

Излаз
-----

На станардни излаз исписати елементе низа уређене на тражени начин,
раздвојене са по једним размаком.

Пример
------

Улаз
~~~~

::

   10
   2 5 3 6 1 8 9 10 11 4

Излаз
~~~~~

::

   2 6 8 10 4 5 3 1 9 11

Ово је само један од могућих излаза. Могућ је, на пример, и излаз

::

   2 4 10 6 8 1 9 3 11 5

или излаз

::

   2 6 8 10 4 3 9 5 11 1

Постоји неколико начина да се низ “у месту” трансформише само једним
проласком кроз низ (ти приступи имају линеарну временску сложеност).
Приказаћемо неколико могућности, све засноване на техници два
показивача.

Парни лево, непарни десно - размена наопаких
--------------------------------------------

Претпоставићемо да су у сваком кораку петље познати индекси :math:`l` и
:math:`d` тако да су елементи низа груписани тако да су:

-  сви елементи на позицијама из интервала :math:`[0, l)` парни,
-  сви елементи на позицијама из интервала :math:`[l, d]` још
   непрегледани и
-  сви елементи на позицијама из интервала :math:`(d, n)` непарни.

Инваријанта је, дакле, да је распоред елемената у низу облика
``ppp???nnn``, где су ``l`` и ``d`` позиција првог тј. последњег
непознатог елемента (обележеног упитником). Током извршавања петље важи
и да је :math:`0 \leq l \leq d + 1 \leq n`.

Иницијализацијом вредности :math:`l` на нулу, а вредности :math:`d` на
:math:`n-1` постижемо да су ови услови на почетку задовољени. Петљу у
приниципу извршавамо док још има непрегледаних елемената тј. док је
:math:`l \leq d`, међутим, у овом задатку можемо је завршити и корак
раније. Петља се извршава док је :math:`l < d`, јер какав год да је тај
последњи непрегледани елемент, он ће се моћи припојити или левом или
десном делу низа и неће бити потребе премештати га.

У телу петље радимо следеће:

-  Прво испитујемо да ли је елемент на позицији :math:`l` паран и ако
   јесте, онда само увећавамо вредност :math:`l` за 1 чиме наметнута
   инваријанта остаје да важи. Заиста, парни су били сви елементи из
   интервала :math:`[0, l)`, паран је и елемент на позицији :math:`l`,
   па су парни сви елементи из интервала :math:`[0, l] = [0, l')`, где
   је :math:`l'=l+1`, нова вредност променљиве :math:`l`. Пошто је
   :math:`d'=d`, елементи на позицијама из интервала :math:`(d', n)` су
   непарни.

-  У супротном, проверавамо да ли је елемент на позицији :math:`d`
   непаран и ако јесте, онда само умањујемо вредност :math:`d` за 1 чиме
   наметнута инваријанта опет остају на снази (аргументација је слична
   оној у претходном случају).

-  На крају, ако ниједна од претходне две провере није успела, знамо да
   је елемент на позицији :math:`l` непаран, а елемент на позицији
   :math:`d` паран, размењујемо их, увећавамо :math:`l` за 1 и умањујемо
   :math:`d` за 1 чиме инваријанта остаје да важи. Заиста, важи да је
   :math:`l'=l+1` и :math:`d'=d-1`. Сви елементи из интервала позиција
   :math:`[0, l)` су парни, а паран је елемент на позицији :math:`l`
   (јер је разменом паран елемент са позиције :math:`d` доведен на
   позицију :math:`l`). Зато су парни сви елементи у интервалу
   :math:`[0, l')`. Слично, пошто су сви елементи у интервалу позиција
   :math:`(d, n)` били непарни, а пошто је након размене непарни елемент
   са позиције :math:`l` доведен на позицију :math:`d`, непарни су и сви
   елементи из интевала :math:`[0, d')`.

Када се петља заврши, распоред је коректан. Наиме, пошто на крају петље
услов :math:`l < d` није испуњен, а пошто је :math:`l \leq d + 1`, тада
је :math:`l=d` или је :math:`l=d+1`.

-  Ако је :math:`l=d+1`, знамо да је низ разбијен на сегмент парних
   елемената на позицијама :math:`[0, l)` и непарних на позицијама
   :math:`(d, n) = [d+1, n) = [l, n)`.

-  Размотримо случај :math:`l=d`.

   -  Ако је елемент на позицији :math:`l` паран, пошто су на основу
      инваријанте парни и сви елементи на позицијама :math:`[0, l)`,
      знамо да ће парни бити сви елементи на позицијама :math:`[0, l]`,
      док ће елементи на позицијама :math:`(d, n) = [l+1, n)` бити
      непарни.

   -  Слично, ако је елемент на позицији :math:`l` непаран, тада су
      парни сви елементи на позицијама :math:`[0, l)`, а непарни су сви
      елементи на позицијама :math:`[l, n)` (јер на основу инваријанте
      знамо да су још непарни и елементи на позицијама
      :math:`(d, n) = (l, n)`).

   У оба случаја је, дакле, постигнут жељени распоред елемената.

Приметимо да смо прекидом петље када је :math:`l=d`, уштедели једну
итерацију петље (што није нарочито значајно), али смо закомпликовали
доказ коректности, па се природно поставља питање колико је та
оптимизација имала смисла.

.. code:: csharp

   using System;
    
   class Dvobojka
   {
       static void razmeni(ref int x, ref int y)
       {
           int tmp = x; x = y; y = tmp;
       }
       
       static void Main(string[] args)
       {
           // ucitavamo niz
           int n = int.Parse(Console.ReadLine());
           int[] a = new int[n];
           string[] str = Console.ReadLine().Split();
           for (int i = 0; i < n; i++)
               a[i] = int.Parse(str[i]);
    
           // odrzavamo uslov
           // [0, l) - parni
           // (d, n) - neparni
           // [l, d] - nepoznati
    
           // u pocetku su svi nepoznati
           int l = 0, d = n-1;
           // dok jos ima nepoznatih elemenata
           while (l < d)
           {
               // ako je na mestu l paran, ostavljamo ga na svom mestu i pomeramo
               // se na naredni element
               if (a[l] % 2 == 0)
                   l++;
               // ako je na mestu d neparan, ostavljamo ga na svom mestu i
               // pomeramo se na prethodni element
               else if (a[d] % 2 != 0)
                   d--;
               else
                   // na mestu l je neparan, a na mestu d je paran broj, pa ih
                   // razmenjujemo i pomeramo se po oba kraja
                   razmeni(ref a[l++], ref a[d--]);
           }
    
           // ispisujemo rezultat
           for (int i = 0; i < n; i++)
               Console.WriteLine(a[i]);
       }
   }


Парни, непарни, па непознати
----------------------------

У овом решењу инваријанта је мало другачија. Памтимо индекс :math:`k` и
текући индекс :math:`i` и претпостављамо да су

-  елементи на позицијама из интервала :math:`[0, k)` парни,
-  елементи из интервала :math:`[k, i)` непарни,
-  елементи из интервала :math:`[i, n)` још непрегледани.

Дакле, намећемо инваријанту да је распоред облика ``pppnnn???``, где је
:math:`i` позиција првог непознатог, а :math:`k` позиција првог непарног
елемената и да је :math:`0 \leq k \leq i \leq n`.

Размотримо како да из инваријанте закључимо како треба иницијализовати
променљиве. Пошто су сви елементи у интервалу :math:`[i, n)`
непрегледани, јасно је да на почетку мора да важи :math:`i=0`. Пошто су
елементи на позицијама :math:`[0, k)` парни и пошто је :math:`k \geq 0`,
јасно је да мора да важи и :math:`k = 0`. Дакле, иницијализацијом
:math:`k` и :math:`i` на нулу постижемо да су ови услови обезбеђени на
почетку петље.

Инваријанта јасно диктира и услов петље. Наиме, петља се извршава док
још има непрегледаних елемената тј. док је :math:`i < n`. У сваком
кораку петље :math:`i` се увећава за 1 (користимо класичну бројачку
петљу ``for`` по променљивој :math:`i`), чиме се сужава интервал
непрегледаних елемената (и чиме се гарантује заустављање).

Размотримо како треба да изгледа тело петље да би инваријанта остала
испуњена.

-  Ако је елемент на текућој позицији :math:`i` паран, онда га
   размењујемо са првим непарним елементом, а то је елемент на позицији
   :math:`k`. Изузетак је случај када је :math:`k=i`, када заправо не
   долази до размене (елемент се мења сам са собом). У оба случаја се
   :math:`k` увећава за 1. Дакле, на основу инваријанте знамо да су
   елементи на позицијама :math:`[0, k)` парни, да је након размене
   елемент на позицији :math:`k` паран, па су парни и сви елементи на
   позицијама :math:`[0, k') = [0, k+1)`. Елементи на позицијама
   :math:`[k', i') = [k+1, i+1)` су непарни. Наиме, ако је :math:`k=i`,
   овај интервал је празан, а ако је :math:`k < i`, тада је пре размене
   елемент на позицији :math:`k` био непаран (јер на основу инваријанте
   знамо да су сви елементи на позицијама :math:`[k, i)` били непарни,
   па самим тим и елемент на позицији :math:`k`, који је сада доведен на
   позицију :math:`i`).

-  У супротном, елемент на позицији :math:`i` је непаран он остаје на
   свом месту и у телу петље није потребно ништа урадити (грану ``else``
   у коду није потребно наводити). Важи :math:`k'=k` и :math:`i'=i`, а
   инваријанта прилично очигледно остаје на снази.

По завршетку петље услов :math:`i < n` није испуњен, па пошто на основу
инваријанте важи :math:`0 \leq k \leq i \leq n`, важи да је
:math:`i = n`. Зато је интервал непознатих :math:`[i, n)` празан, сви
елементи из интервала :math:`[0, k)` су парни, из интервала
:math:`[k, i) = [k, n)` су непарни и постигнут је тражени распоред.

.. code:: csharp

   using System;
    
   class Dvobojka
   {
       static void razmeni(ref int x, ref int y)
       {
           int tmp = x; x = y; y = tmp;
       }
       
       static void Main(string[] args)
       {
           // ucitavamo niz
           int n = int.Parse(Console.ReadLine());
           int[] a = new int[n];
           string[] str = Console.ReadLine().Split();
           for (int i = 0; i < n; i++)
               a[i] = int.Parse(str[i]);
    
           // odrzavamo uslov
           // [0, k) - parni
           // [k, i) - neparni
           // [i, n) - nepoznati
    
           // u pocetku su svi elementi nepoznati
           int k = 0;
           for (int i = 0; i < n; i++)
               // ako je element paran razmenjujemo ga sa prvim neparnim
               if (a[i] % 2 == 0)
                   razmeni(ref a[i], ref a[k++]);
           // a ako je neparan, ne pomeramo ga
    
           // ispisujemo rezultat
           for (int i = 0; i < n; i++)
               Console.WriteLine(a[i]);
       }
   }
    
         
