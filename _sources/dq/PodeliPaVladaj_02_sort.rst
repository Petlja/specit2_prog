Подели па владај - сортирање
============================

Техником подели-па-владај се могу добити ефикасни алгоритми сортирања.
Најпознатији од њих су:

- сортирање обједињавањем (енгл. merge sort)
- брзо сортирање (енгл. quick sort)

    
Подели па владај - сортирање обједињавањем
------------------------------------------

Алгоритам сортирања обједињавањем дели низ на два дела чије се дужине
разликују највише за 1 (уколико је дужина низа паран број, онда су ова
два дела једнаких дужина), рекурзивно сортира сваки од њих и затим
обједињује сортиране половине. За обједињавање је неопходно користити
додатни, помоћни низ, а на крају се обједињени низ копира у полазни
низ. Излаз из рекурзије је случај једночланог низа (случај празног
низа не може да наступи осим ако је полазни низ празан).

Кључна операција у овом алгоритму је операција обједињавања сортираних
низова. На пример, обједињавањам сортираних низова `a` и `b` добија се
сортирани низ `c`.


::

   a:  1 3 4 7 9 11                   b:  2 5 8 9 10 12 14

              c: 1 2 3 4 5 7 8 9 9 10 11 12 14

На наредној слици преузетој са Википедије (аутор је корисник именом
Swfung8) можеш видети анимацију која приказује како функционише
алгоритам сортирања обједињавањем.

.. image:: ../../_images/dq/merge.gif
   :align: center
           
Два већ сортирана низа могу се објединити у трећи сортирани
низ само једним проласком кроз низове (тј. у линеарном времену
:math:`O(m + n)` где су :math:`m` и :math:`n` димензије полазних
низова). 

.. code-block:: csharp
                
    void Merge(int[] a, int[] b, int[] c) 
    {
       int i = 0, j = 0, k = 0;
       while (i < a.Length && j < b.Length)
          c[k++] = a[i] < b[j] ? a[i++] : b[j++];
       while(i < a.Length) c[k++] = a[i++];
       while(j < b.Length) c[k++] = b[j++];
    }

У приказаној имплементацији, заснованој на техници два показивача,
паралелно се пролази кроз низ ``a`` димензије ``m`` и низ ``b``
димензије ``n``. Променљива ``i`` чува текућу позицију у низу ``a``,
док променљива ``j`` чува текућу позицију у низу ``b``. Текући
елементи се пореде и мањи се уписује у низ ``c`` (на текућу позицију
``k``), при чему се напредује само у низу из којег је тај мањи елемент
узет. Поступак се наставља док се не стигне до краја једног од
низова. Када се краћи низ испразни, евентуални преостали елементи из
дужег низа се надовезују на крај низа ``c``.


Функција ``mergesort`` сортира део низа ``a[l, d]``, уз коришћење низа
``tmp`` као помоћног.


.. code-block:: csharp
                
   void MergeSort(int[] a, int l, int d, int[] tmp) 
   {
      if (l < d)
      {
         int n = d - l + 1, s = l + n/2;
         int n1 = n/2, n2 = n - n/2;
         MergeSort(a, l, s-1, tmp);
         MergeSort(a, s, d, tmp);
         Merge(a, l, n1, a, s, n2, tmp, 0);
         Array.Copy(tmp, 0, a, l, d - l + 1);
      }
   }

Променљива ``n`` чува број елемената који се сортирају у оквиру овог
рекурзивног позива, а променљива ``s`` чува средишњи индекс у низу
између ``l`` и ``d``. Рекурзивно се сортира ``n1 = n/2`` елемената
између позиција ``l`` и ``s-1`` и ``n2 = n - n/2`` елемената између
позиција ``s`` i ``d``. Након тога, сортирани поднизови обједињују се
у помоћни низ. Пошто се више не обједињују цели низови, већ делови
једног низа, функцију обједињавања морамо мало прилагодити.

.. code-block:: csharp

    // objedinjava se na sortiranih elemenata niza a od pozicije a0
    // sa nb sortiranih elemenata niza b od pozicije b0 i rezultat se
    // smesta u niz c od pozicije c0 (pretpostavlja se da u nizu c ima
    // dovoljno prostora da se smeste rezultat)
    static void Merge(int[] a, int a0, int na,
                      int[] b, int b0, int nb,
                      int[] c, int c0) 
    {
       int i, j, k;
       i = a0, j = b0, k = c0;
       while (i < a0 + na && j < b0 + nb)
          c[k++] = a[i] < b[j] ? a[i++] : b[j++];
       while(i < a0 + na) c[k++] = a[i++];
       while(j < b0 + nb) c[k++] = b[j++];
    }


Помоћни низ може се пре почетка сортирања динамички алоцирати и
користити кроз рекурзивне позиве.

.. code-block:: csharp

   // sotira se niz a             
   static void MergeSort(int[] a) 
   {
       // alociramo pomocni niz
       int[] tmp = new int[a.Length];
       MergeSort(a, 0, a.Length-1, tmp);
   }

Добијена функција сортирања има гарантовану сложеност најгорег случаја
:math:`O(n\log{n})`, што значи да је много бржа од функција заснованих
на сортирању селекцијом или сортирању уметањем чија је сложеност
:math:`O(n^2)`.
   
Подели па владај - брзо сортирање
---------------------------------

У сваком кораку алгоритма сортирања један елемент (обично називан
\емпх{пивот}) се доводи на своје место (пожељно близу средине
низа). Да би након тога, проблем могао бити сведен на сортирање два
мања подниза, потребно је приликом довођења пивота на своје место
груписати све елементе мање или једнаке од њега лево од њега, а све
елементе веће од њега десно од њега (ако се низ сортира неопадајуће).
То прегруписавање елемената низа, *корак партиционисања* кључни
је корак алгоритма брзог сортирања.

Брзо сортирање се може имплементирати на следећи начин. Позив
``qsort_(a, l, d)`` sortira deo niza ``a[l, d]``.


.. code-block:: csharp

   void QSort(int[] a, int l, int d) 
   {
       if (l < d)
       {
           Razmeni(a, l, IzborPivota(a, l, d));
           int p = Particionisanje(a, l, d);
           QSort(a, l, p - 1);
           QSort_(a, p + 1, d);
       }
   }

   void QSort(int[] a) 
   {
      Qsort(a, 0, n-1);
   }


Функција ``IzborPivota`` бира за пивот неки елемент низа ``a[l, d]`` и
враћа његов индекс (у низу ``a``). Позивом функције ``Razmeni`` пивот
се поставља на позицију ``l``. Функција ``Particionisanje`` врши
партиционисање низа (претпостављајући да се пре партиционисања пивот
налази на позицији ``l``) и враћа позицију на којој се налази пивот
након партиционисања. Функција се позива само за низове који имају
више од једног елемента, па је у сваком позиву ``l`` мање или једнако
``d``. Након позива функције ``Particionisanje`` елементи низа треба
да буду прерасподељени тако да су сви елементи низа ``a[l, p-1]`` мањи
или једнаки елементу ``а[p]``, док су сви елементи низа ``a[p+1, d]``
већи или једнаки од елемента ``a[p]``.

У пракси, најбоље резултате код сортирања дугачких низова даје управо
алгоритам брзог сортирања. Међутим, за сортирање краћих низова наивни
алгоритми (на пример, сортирање уметањем) могу да се покажу
погоднијим.  Већина реалних имплементација сортирања користи хибридни
приступ --- излаз из рекурзије се врши код низова који имају неколико
десетина елемената и на њих се примењује сортирање уметањем
(енгл. insertion sort).
   

Имплементација партиционисања
'''''''''''''''''''''''''''''

Да би сортирање било ефикасно, корак партиционисања (тј. функција
``Particionisanje``) треба да буде извршен у линеарном времену.
Партиционисање се обично заснива на техници два показивача.


**Кернинген-Ричи**

Прву варијанту алгоритма ћемо организовати тако да се у првој фази
алгоритма на почетку низа налази пивот, затим елементи низа који су
мањи или једнаки пивоту, затим елементи који су већи од пивота и на
крају елементи који још нису испитани. Оваква имплементација је
изложена у чувеној књизи Кернингена и Ричија о програмском
језику C. Памтићемо позицију :math:`m` која ће указивати на границу
између елемената мањих и једнаких од пивота и оних који су већи од
њега, као и позицију :math:`i` која ће указивати на први необрађен
(неиспитан) елемент. Дакле, желимо да током извршавања петље важи да
се пивот налази на позицији :math:`l`, да су на позицијама :math:`(l,
m)` елементи који су мањи или једнаки од пивота и да су на позицијама
:math:`[m, i)` елементи који су већи од пивота. Дакле, све време
извршавања петље треба да важи овакав распоред:

::

                  m        i            
   = <= <= <= <=  >  >  >  ?  ?  ?  ?
   l                                d


   l         pivot
   (l, m)    <=
   [m, i)    >
   [i, d]    ?

   
Да би овај услов био испуњен на почетку петље, потребно је да
поставимо вредности променљивих тако да важи :math:`m = i = l+1`, јер
су тада оба интервала :math:`(l, m)` и :math:`[m, i)` празна.

::

      i
      m                          
   =  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?
   l                             d

   
У сваком кораку петље ћемо обрађивати један по један непознати елемент
(и то први, онај на позицији :math:`i`), док год их има. Пошто су они
у интервалу :math:`[i, d]`, петљу ћемо извршавати док год је :math:`i
\leq d`. Постоје две могућности за елемент :math:`a_i`.

- Ако је :math:`a_i` већи од пивота, потребно је само да повећамо
  :math:`i` за један да би инваријанта била одржана.
- Ако је :math:`a_i` мањи или једнак од пивота можемо га заменити са
  елементом на позицији :math:`m`, и увећати променљиве :math:`m` и
  :math:`i` за један.

На крају петље је :math:`i = d+1`, па су сви елементи у интервалу
:math:`(l, m)` мањи или једнаки од пивота, а сви у интервалу
:math:`[m, d]` већи од њега.

::

                    m              i
   = <= <= <= <= <= >  >  >  >  >    
   l                            d

   
Разменом елемената на позицијама :math:`l` и :math:`m-1` долазимо у
ситуацију у којој се на позицијама :math:`[l, m-1]` налазе елементи
који су мањи или једнаки од пивота, пивот се налази на позицији
:math:`m-1`, а елементи на позицијама :math:`[m, d]` су већи од
пивота. Ако након завршетка петље важи :math:`m=d+1`, не постоје
елементи мањи или једнаки пивоту, размена елемената на позицијама
:math:`l` и :math:`m-1`, неће произвести никакав ефекат, али ће сва
наведена тврђења и даље бити тачна.


::

                     m             i
   <= <= <= <= <= =  >  >  >  >  >    
   l                             d
   

Програмски кôд лако следи из претходне анализе (практично доказа
његове коректности).

.. code-block:: csharp

   void Particionisanje(int[] a, int l, int d)
   {
      int m = l+1;
      for (int i = l+1; i <= d; i++)
         if (a[i] <= a[l])
           Razmeni(a[i], a[m++])
      Razmeni(a[l], a[m-1]);
      return m-1;
   }


На сајту Математичког факултета Универзитета у Београду налази се
`апликација <http://www.matf.bg.ac.rs/~filip/algoritmi/sort.html>`__
која ће ти помоћи да провериш своје разумевање овог алгоритма. Одабери
алгоритам партиционисања по Кернингену и Ричију и затим покушај да на
датом примеру прикажеш сваку размену која се врши током његовог
извршавања.
   
**Обилазак са два краја**

Још један начин имплементирања корака партиционисања је да се низ
обилази паралелно са два краја и да се, када се на левом крају наиђе
на елемент који је већи, а на десној на елемент који је мањи од
пивота, изврши њихова размена. Петљу можемо организовати и тако да се
пивот налази на позицији :math:`l`, да су на позицијама из интервала
:math:`(l, m)` елементи мањи или једнаки од пивота, а да су на
позицијама из интервала :math:`(v, d]` елементи већи од пивота.

::

                 m        v        
   = <= <= <= <= ?  ?  ?  ?  >  >  >
   l                               d

   l       pivot
   (l, m)  <=
   [m, v]  ?
   (v, d]  >
   
   
На почетку можемо иницијализовати променљиве тако да је :math:`m=l+1`
и :math:`v = d` и инваријанта ће бити испуњена. 


::

      m                          v
   =  ?  ?  ?  ?  ?  ?  ?  ?  ?  ?
   l                             d

У интервалу :math:`[m, v]` се налазе елементи чији статус још није
познат. Покушавамо у сваком кораку да сузимо тај интервал, све док се
не испразни, тј. све док је :math:`m \leq v`.

- Ако је :math:`a_m` мањи или једнак пивоту све што треба да урадимо
  је да повећамо :math:`m` за један.
- Ако је :math:`a_v` већи од пивота, све што треба да урадимо је да
  смањимо :math:`v` за један.
- Ако ниједно од та два није испуњено, тада можемо да заменимо
  :math:`a_m` и :math:`a_v`, да повећамо :math:`m` за један и смањимо
  :math:`v` за један.


Када се петља заврши, последњи елемент који је мањи или једнак пивоту
се налази на позицији :math:`m-1 = v`.


::

                  v  m
   = <= <= <= <= <=  >  >  >  >  >
   l                             d


Након тога можемо заменити тај елемент са пивот и тако успешно
завршити партиционисање.

::

                  v  m
   <= <= <= <= <= =  >  >  >  >  >
   l                             d


Имплементацију је поново веома једноставно извршити након претходне дискусије.
   
.. code-block:: csharp
                
   int Particionisanje(int[] a, int l, int d) 
   {
      int m = l+1, v = d;
     
      while (m <= v)
      {
        if (a[m] <= a[l])
           m++;
        else if (a[v] > a[l])
           v--;
        else
           Razmeni(a, m++, v--);
      }
     
      Razmeni(a, l, v);
      return v;
   }

И функционисање овог алгоритма можеш испробати кроз `апликацију
<http://www.matf.bg.ac.rs/~filip/algoritmi/sort.html>`__ која је
доступна на сајту Математичког факултета Универзитета у Београду.
   

Избор пивота
''''''''''''

Да би алгоритам био ефикасан, потребно је да позиција пивота након
партиционисања буде близу средини низа (како би дужина два подниза на
које се проблем своди било приближно једнака :math:`n/2`). Међутим,
одређивање средишњег члана у низу бројева (што представља идеалну
стратегију за функцију ``IzborPivota``) је проблем који није значајно
једноставнији од самог сортирања. С обзиром на то да се очекује да је
имплементација функције избора пивота веома брза (избор се обично врши
у мало броју корака), обично се не гарантује да ће за пивот бити
изабран управо средњи члан, већ се користе хеуристике које за пивот
бирају елементе који нису далеко од средишње позиције у
низу. Нагласимо да се за сваку стратегију избора пивота (која не
користи случајно изабране бројеве) може конструисати низ такав да у
сваком кораку избор пивота буде најгори могући --- онај који дели низ
на низове дужине ``0`` и ``n-1``, што доводи до неефикасног алгоритма
сортирања (алгоритма квадратне сложености). Међутим, већина стратегија
је таква да се у просечном случају може очекивати да се дужине
поднизова не разликују много, те дају просечну сложеност
(:math:`O(n\log{n})`).

Ако се може претпоставити да су елементи низа насумично распоређени
(што се увек може постићи уколико се пре примене сортирања низ
пермутује на случајан начин, за шта је довољно линеарно време), било
који елемент низа се може узети за пивот. На пример,


.. code-block:: csharp

   static int IzborPivota(int[] a, int l, int d) 
   {
       return l;
   }

или 

.. code-block:: csharp

   
   static int izbor_pivota(int[] a, int l, int d, Random rnd) 
   {
      return rnd.Next(l, d+1);
   }

Нешто боље перформансе могу се постићи уколико се за пивот узима
средњи од три случајно насумично одабрана елемента низа.


.. code-block:: csharp

   
   static int IzborPivota(int[] a, int l, int d, Random rnd) 
   {
      int p1 = rnd.Next(l, d+1);
      int p2 = rnd.Next(l, d+1);
      int p3 = rnd.Next(l, d+1);

      if ((a[p1] > a[p2]) != (a[p1] > a[p3]))
          return p1;
      else if ((a[p2] > a[p1]) != (a[p2] > a[p3]))
          return p2;
      else
          return p3;
   }

У имплементацији се користи то да се оператор ``!=`` на типу ``bool``
понаша као ексклузивна дисјункција и ``p != q`` је тачно ако и само
ако је тачно један од израза ``p`` и ``q`` тачан. Зато услов ``(a[p1]
> a[p2]) != (a[p1] > a[p3])`` практично тражи да је ``a[p1]`` већи од
тачно једног од елемената ``a[p2]`` и ``a[p3]`` (не и од оба).

На наредној слици преузетој са Википедије (аутор је корисник RolandH)
можеш видети анимацију која приказује како функционише алгоритам брзог
сортирања.

.. image:: ../../_images/dq/quick.gif
   :align: center
