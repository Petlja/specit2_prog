
..
  Пример: бинарни запис броја
  reading

Пример: бинарни запис броја
===========================

Напиши програм који на основу неозначеног целог броја :math:`n` формира
и исписује његов 32-битни бинарни запис.

Улаз
----

Са стандардног улаза се уноси број :math:`n`
(:math:`0 \leq n \leq 2^{32}-1`).

Излаз
-----

На стандардни излаз исписати 32-битни бинарни запис броја :math:`n`.

Пример 1
--------

Улаз
~~~~

::

   123456

Излаз
~~~~~

::

   00000000000000011110001001000000

Пример 2
--------

Улаз
~~~~

::

   16777215

Излаз
~~~~~

::

   00000000111111111111111111111111

Решење
------

Нека је низ од 32 логичке вредности попуњен вредности ``false``. Бинарни
запис одређујемо тако што одређујемо једну по једну бинарну цифру броја,
здесна налево. У сваком кораку петље одређујемо остатак при дељењу броја
:math:`n` са :math:`2`, и на наредно место у низу (у кораку :math:`i` на
место :math:`i`) уписујемо ``true`` ако је тај остатак једнак 1. На
крају петље, исписујемо садржај низа уназад.

.. code:: csharp

   using System;

   class Program
   {
       static void Main(string[] args)
       {
           // broj koji se prevodi
           ulong n = ulong.Parse(Console.ReadLine());
           
           // niz binarnih cifara, redom, od cifre najmanje do cifre najvece
           // tezine
           bool[] binarneCifre = new bool[32];
           // prevodjenje
           for (int i = 0; n > 0; i++, n /= 2)
               binarneCifre[i] = n % 2 == 1;

           // ispisujemo rezultat (od cifre najmanje tezine
           for (int i = 31; i >= 0; i--)
               Console.Write(binarneCifre[i] ? '1' : '0');
           Console.WriteLine();
       }
   }

Докажимо формално коректност овог алгоритма, тј. претходног програма.

**Лема:** Услов :math:`2^i \cdot n + b = n_0` је инваријанта петље, где
је :math:`b` број тренутно кодиран низом бинарних цифара (ако логичка
вредност на позицији :math:`k` у низу одговара цифри :math:`b_k`, нека
је :math:`b = \sum_{k=0}^{31} b_k 2^k`), где је :math:`i` текућа
вредност променљиве ``i``, док је :math:`n_0` почетна, а :math:`n`
текућа вредност неозначеног броја ``n``.

-  Заиста на почетку је :math:`n = n_0`, :math:`i = 0` и :math:`b = 0`
   па тврђење важи.

-  Претпоставимо да тврђење важи при уласку у петљу. Променљиве се током
   извршавања тела и корака петље мењају на следећи начин.
   :math:`n' = n \div 2`, :math:`b' = b + 2^i\cdot (n \mod 2)` и
   :math:`i' = i+1`. Тада је :math:`2^{i'} \cdot n' + b'` =
   :math:`2^{i+1} \cdot (n \div 2) + b + 2^i \cdot n \mod 2` =
   :math:`2^i\cdot(2\cdot (n \div 2) + n \mod 2) + b`. На основу
   дефиниције целобројног дељења важи да је
   :math:`2 \cdot (n \div 2) + n \mod 2 = n`, па је вредност претходног
   израза једнака :math:`2^i\cdot n + b`, а на основу претпоставке о
   томе да инваријанта важи на уласку у тело петље знамо да је то
   једнако :math:`n_0`.

**Теорема:** По завршетку алгоритма низ садржи бинарни запис неозначеног
броја ``n``.

Како је по изласку из петље :math:`n=0`, на основу инваријанте важи да
је :math:`b = n_0` тј. да низ садржи бинарни запис полазног броја.

Заустављање је прилично очигледно јер је ``n`` ненегативан број који се
у сваком кораку стриктно смањује (све док не достигне нулу).
