
..
  Пример: аритметички троугао
  reading

Пример: аритметички троугао
===========================

**Задатак:** Колики је збир бројева у датом реду следећег троугла?

::

            1
         2  3  4
      5  6  7  8  9
   10 11 12 13 14 15 16
           ...

Улаз
----

Редни број :math:`k` (:math:`1 \leq k \leq 5\cdot 10^5`), реда троугла
чији збир треба израчунати (бројање редова почиње од 1).

Излаз
-----

Збир вредности у задатом реду троугла.

Пример
------

Улаз
~~~~

::

   3

Излаз
~~~~~

::

   35

Решење коришћењем петљи
-----------------------

До решења се може доћи коришћењем петљи. У првој петљи одређујемо први
елемент :math:`k`-тог реда, а уз то одређујемо и број елемената у
њему. Први елемент одређујемо тако што саберемо број елемената у
претходних :math:`k-1` редова, док број елемената сваког реда тако што
у сваком кораку број елемената претходног реда увећавамо за два (сваки
наредни ред има тачно два елемента више од претходног). Дакле, у петљи
одржавамо почетак и број елемената текућег реда (иницијализујемо их на
један, јер први ред почиње од један и има тачно један елемент) и
:math:`k-1` пута почетак реда увећавамо за број елемената текућег
реда, а број елемената текућег реда за два.

Након тога, у другој петљи одређујемо збир елемената у :math:`k`-том
реду, тако што на збир који иницијализујемо на нулу додајемо један по
један елемент тог реда (коришћењем алгоритма сабирања серије бројева -
елементи су узастопни природни бројеви, па их је лако набројати.

Докажимо формално коректност овог поступка. Инваријанта петље је да
након :math:`m` извршавања њеног тела важи да је :math:`i = m+1` и
:math:`1 \leq i \leq k`, као и да променљива ``pocetak`` садржи први
елемент реда :math:`i = m+1`, а променљива ``brojElemenata`` садржи број
елемената реда :math:`i = m+1`.

-  Пошто се променљива ``i`` иницијализује на вредност :math:`1`, након
   :math:`m=0` корака важи да је :math:`1 = 0 + 1` и
   :math:`1 \leq 1 \leq k`. Пошто су и обе променљиве иницијализоване на
   вредност :math:`1`, након :math:`m=0` корака петље, променљиве заиста
   садрже први елеменат и број елемената реда
   :math:`i = m + 1 = 0+1 = 1`.

-  Претпоставимо да инваријанта важи након :math:`m` корака петље и да
   је услов петље испуњен тј. да је :math:`i < k`.

   Докажимо да тврђење важи и након :math:`m'=m+1` извршавања тела и
   корака петље. Пошто након извршавања корака важи :math:`i' = i+1`, а
   пошто је на основу индуктивне хипотезе важило да је :math:`i = m+1`,
   важи и да је :math:`i' = m'+1`. Пошто је услов петље био испуњен,
   важило је :math:`i < k`, па уз индуктивну претпоставку
   :math:`1 \leq i \leq k`, важи :math:`1 \leq i' \leq k`.

   Означимо са :math:`p` и :math:`b` вредности променљивих ``pocetak`` и
   ``brojElemenata`` на улазу у тело петље, а са :math:`p'` и :math:`b'`
   њихове нове вредности, након извршења тела и корака петље. Анализом
   додела у телу петље, јасно видимо да је :math:`p' = p + b` и
   :math:`b' = b+2`. На основу претпоставке важи да је :math:`p` први
   елемент реда :math:`i=m+1`, а да је :math:`b` број елемената реда
   :math:`i=m+1`. Сабирањем првог елемента било ког реда у троугла и
   броја елемената тог реда троугла добија се први елемент наредног реда
   троугла. Дакле, важи да је :math:`p+b` први елемент реда
   :math:`i+1 = m+2` троугла, па, важи да је :math:`p'=p+b` први елемент
   реда :math:`i' = i+1 = m+2 = m' + 1`. На основу дефиниције троугла
   важи јасно и да сваки наредни ред има и два елемента више него
   претходни. Зато, пошто је :math:`b` број елемената реда :math:`m+1`,
   важи и да је :math:`b' = b+2` број елемената реда :math:`i' = m'+1`.

-  На крају петље услов није испуњен, па важи да је :math:`i \geq k`. Уз
   услов :math:`1 \leq i \leq k`, мора да важи да је :math:`i = k`. На
   основу инваријанте знамо да променљива ``pocetak`` садржи број
   елемената реда :math:`i = m+1 = k`. Дакле, петља је коректно извршила
   свој задатак и у променљиву ``pocetak`` сместила први елемент реда
   :math:`k`.

Приметимо да смо у овој петљи увели и нову променљиву којом смо
регистровали број елемената у текућем реду троугла. То што смо ту
променљиву имали на располагању нам је помоглно да ажурирамо вредност
почетног елемента наредног реда, међутим, “кредит” који смо добили на
почетку тела петље морали смо да вратимо на крају тако што смо морали да
ажурирамо и вредност те променљиве (и тако је припремимо за наредну
итерацију). Ова техника је позната под именом **ојачавање индуктивне
хипотезе** и често се користи приликом конструкције алгоритама.

На сличан начин се може формално доказати и коректност друге петље
(инваријанта је да након :math:`m` њених корака променљива
``zbirRedaTrougla`` садржи збир првих :math:`m` елемената реда
:math:`k`, а да променљива :math:`i` садржи вредност елемента на
позицији :math:`m` у том реду, ако се позиције броје од 0).

У првој петљи обилазимо :math:`k` редова којима одређујемо почетак
помоћу две операције сабирања. Пажљивом анализом можемо закључити да у
реду :math:`k` има :math:`2k-1` елемената (мада ту чињеницу нисмо
употребили у програму), који се у другој фази сабирају. Сложеност обе
фазе, па и укупног решења је, дакле, :math:`O(k)`. Задатак, наравно,
може да се реши и у мањој сложености од ове, без коришћења петљи.

.. code:: csharp

   using System;
    
   class Program
   {
       static void Main()
       {
           long k = long.Parse(Console.ReadLine());
    
           // odredjujemo prvi broj u k-tom redu trougla 
           long pocetak = 1;
           long brojElemenata = 1;
           for (long i = 1; i < k; i++)
           {
               pocetak += brojElemenata;
               brojElemenata += 2;
           }
    
           // odredjujemo zbir elemenata u k-tom redu trougla
           long zbirRedaTrougla = 0;
           for (long i = pocetak; i < pocetak + brojElemenata; i++)
               zbirRedaTrougla += i;
           
           Console.WriteLine(zbirRedaTrougla);
       }
   }
