
..
  Индуктивна/рекурзивна конструкција
  reading

Индуктивно-рекурзивна конструкција
==================================

Кључна идеја у конструкцији алгоритама је то да је конструкција
алгоритама веома тесно повезана са доказивањем теорема математичком
индукцијом. **Математичка индукција** је следећа особина природних
бројева. Нека је :math:`P` произвољно својство које се може формулисати
у теорији природних бројева. Тада важи

.. math:: (P(0) \wedge (\forall n)(P(n) \Rightarrow P(n+1))) \Rightarrow (\forall n)(P(n))

Дакле, да бисмо доказали да сваки природан број има неко својство
:math:`P` (тј. да бисмо доказали :math:`(\forall n)(P(n))`), довољно је
да докажемо да нула има то својство (тј. :math:`P(0)`) и да докажемо да
чим неки број има то својство, има га и његов следбеник (тј. да докажемо
:math:`(\forall n)(P(n) \Rightarrow P(n+1))`). Прво тврђење се назива
**база индукције**, а друго **индуктивни корак**. Приницип математичке
индукције је прилично јасан - на основу базе знамо да 0 има својство
:math:`P`, на основу корака да њен следбеник тј. 1 има својство
:math:`P`, на основу корака да његов следбеник тј. 2 има својство
:math:`P` итд. Интуитивно нам је јасно да на овај начин можемо стићи до
било ког природног броја, који сигурно мора имати својство :math:`P`.
База се може формулисати и за веће вредности од нуле, али онда само
можемо да тврдимо да елементи који су већи или једнаки од базе имају
својство :math:`P`.

Основни приступ конструкцији алгоритама је тзв. **индуктивни** тј.
**рекурзивни** приступ. Он подразумева да се решење проблема веће
димензије проналази тако што умемо да решимо проблем истог облика, али
мање димензије и да од решења тог проблема добијемо решење проблема веће
димензије. Притом за почетне димензије проблема решење морамо да
израчунавамо директно, без даљег свођења на проблеме мање димензије. Ако
се приликом свођења димензија проблема увек смањује, конструисани
алгоритми ће се увек заустављати.

-  Имплементација алгоритма може бити таква да променљиве унутар петље
   итеративно ажурирају своје вредности кренувши од вредности које
   представљају решења елементарних проблема, па до крајњих вредности
   које представљају решења задатог проблема. Пошто је ово прилично
   слично принципу математичке индкуције, кажемо да је алгоритам
   дефинисан **индуктивно**.

-  Имплементација може бити таква да функција која решава полазни
   проблем сама себе позива да би решила проблем истог облика, али мање
   димензије (осим у случају елементарних проблема, који се директно
   решавају) и тада кажемо да је алгоритам дефинсан **рекурзивно**.

У наставку овог поглавља ћемо се бавити итеративно имплементираним,
индуктивно конструисаним алгоритмима. Рекурзија је јако важна техника,
којом ћемо се посебно бавити (укључујући и питање коректности
рекурзивних функција).


Индуктивна конструкција лежи у основни практично свих итеративних
алгоритама које смо до сада разматрали. На пример, алгоритам
израчунавања збира серије бројева (на пример, збира елемената неког
низа) почива на томе да знамо да израчунамо збир празне серије (то је
0) и да ако знамо збир серије од :math:`k` елемената, тада умемо да
израчунамо и збир серије која се добија проширивањем те серије
додатним :math:`k+1`-вим елементом (то радимо тако што дотадашњи збир
увећамо за тај нови елемент). 

.. code:: csharp

    int zbir = 0;
    for (int i = 0; i < a.Length; i++)
        zbir = zbir + a[i];


Дакле, и у овом алгоритму имамо индуктивну базу (која одговара
иницијализацији променљиве пре уласка у петљу) и индуквитни корак
(који одговара телу петље, у ком се ажурира вредност резултујуће
променљиве, у овом случају збира). База може одговарати и случају
једночланог (а не обавезно празног) низа. То одговара варијанти
алгоритма у којој збир иницијализујемо на први елемент низа, па га
увећавамо редом за један по један елемент од позиције 1 надаље.

Дефинисање алгоритама индуктивно-рекурзивом конструкцијом је у веома
тесној вези са доказивањем њихове коректности. Иако постоје формални
оквири за доказивање коректности императивних програма (пре свега
*Хорова логика*), ми ћемо се бавити искључиво неформалним доказима и
веза између логике у којој вршимо доказивање и (императивног)
програмског језика у којем се програм изражава биће прилично неформална.

Рецимо и да ћемо приликом доказивања коректности програма обично
игнорисати ограничења записа бројева у рачунару и подразумеваћемо да је
опсег бројева неограничен и да се реални бројеви записују са максималном
прецизношћу. Дакле, нећемо обраћати пажњу на грешке које могу настати
услед прекорачења или поткорачења вредности током извођења аритметичких
операција.

Инваријанте петље
-----------------

Један од основних појмова у анализи и разумевању итеративних програма су
**инваријанте петљи**. То су логички услови који важе све време током
извршавања тела петље и након извршавања петље гарантују коректност
алгоритма који та петља имплементира. Инваријанте суштински описују
значење свих променљивих унутар петље. Илуструјмо појам инваријанте на
једном једноставном примеру.

**Проблем:** Дефинисати функцију која одређује минимум непразног низа
бројева и доказати њену коректност.

Размотримо следећу, класичну имплементацију алгоритма за одређивање
минимума.

.. code:: csharp

   class Program
   {
       static int MinNiza(int[] a)
       {
           int m = a[0];
           for (int i = 1; i < a.Length; i++)
               m = Math.Min(m, a[i]);
           return m;
       }

       static int Main()
       {
           int[] a = {3, 5, 4, 1, 6, 2, 7};
           Console.WriteLine(MinNiza(a));
       }
   }

У сваком кораку петље, део низа чији минимум знамо постаје дужи за по један
елемент. Алгоритам креће од низа дужине :math:`1` и поставља променљиву
``m`` на вредност првог елемента низа :math:`a_0`. У сваком кораку
петље, претпостављамо да променљива :math:`m` садржи вредност минимума
првих :math:`i` елемената низа, а онда у телу петље обрађени део низа
проширујемо додајући :math:`i+1`-ви елемент низа, на позицији :math:`i`.
Минимум проширеног низа се израчунава као минимум минимума првих
:math:`i` елемената низа (чија је вредност смештена у променљивој ``m``)
и додатног елемента низа :math:`a_i`. Након једног (сваког) извршавања тела петље,
део низа чији минимум је познат је проширен на :math:`i+1` елемент. На крају
петље је :math:`i` једнако дужини низа, па променљива ``m`` садржи
минимум целог низа.

Пре него што пређемо на формални доказ претходог разматрања, скренимо
пажњу на то да променљиве у математици и у програмирању имају различите
особине. Наиме, променљиве у математици означавају (именују) једну
вредност док променљиве у (императивном) програмирају имају динамички
карактер и мењају своје вредности током извршавања програма. На пример,
бројачка променљива ``i`` у некој петљи може редом имати вредности 1, 2
и 3. Да бисмо направили разлику између ове две различите врсте
променљивих, користићемо различит фонт - променљиву програма ћемо
обележавати са ``i``, а њену вредност са :math:`i`. Ако желимо да
разликујемо стару и нову вредност променљиве ``i``, користићемо ознаке
:math:`i` и :math:`i'`. Ако желимо да нагласимо да је променљива редом
узимала неку серију вредности, користићемо ознаке :math:`i_0` (почетна
вредност променљиве ``i``), :math:`i_1`, :math:`i_2`, … У ситуацијама у
којима се вредност променљиве не мења (на пример, ако је дужина низа
током целог трајања програма иста), нећемо обраћати пажњу на разлику
између променљиве програма (нпр. ``n``) и њене вредности (нпр.
:math:`n`). Елементе низова ћемо такође обележавати индексима и обично
ћемо претпостаљати да бројање креће од нуле (нпр. :math:`а_0`,
:math:`а_1`, …).

Формално, можемо доказати следећу теорему.

**Теорема:** Ако је низ :math:`a` дужине :math:`n \geq 1`, онда непосредно
пре почетка петље, у сваком кораку петље (и пре и после извршења тела 
петље у том кораку), као и након извршавања целе петље важи да је
:math:`1 \leq i \leq n` и да је :math:`m` минимум првих :math:`i`
елемената низа (где је :math:`i` текућа вредност променљиве ``i``, а
:math:`m` текућа вредност променљиве ``m``).

Ово тврђење можемо доказати индукцијом и то по броју извршавања тела
петље (обележимо тај број са :math:`k`). Напоменимо само да ћемо петљу
``for`` сматрати само скраћеницом за петљу ``while``, тако да ћемо
иницијализацију петље сматрати за кôд који се извршава пре петље, док
ћемо корак петље сматрати као последњу наредбу тела петље.

.. code:: csharp

       int n = a.Length;
       int m = a[0];
       int i = 1;
       while (i < n)
       {
           m = Math.Min(m, a[i]);
           i++;
       }

Такође, имплицитно ћемо подразумевати да се током извршавања петље низ
ни у једном тренутку не мења (и то се експлицитно може доказати
индукцијом). Ни променљива ``n`` не мења своју вредност.

Да бисмо у доказу били прецизнији, обележимо са
:math:`m_0, m_1, \ldots, m_k, \ldots` вредности променљиве ``m``, а са
:math:`i_0, i_1, \ldots, i_k, \ldots` вредност променљиве ``i`` након
:math:`0, 1, \ldots, k, \ldots` извршавања тела петље. Пошто променљива
``n`` не мења своју вредност, употребљаваћемо само вредност :math:`n`.

-  Базу индукције чини случај :math:`k=0` тј. случај када се тело петље
   није још извршило. Пре уласка у петљу променљива ``i`` се
   иницијализује на :math:`1` (важи :math:`i_0 = 1`). Пошто
   претпостављамо да је низ непразан, важи да је
   :math:`1 \leq i = i_0 = 1 \leq n`. Променљива ``m`` се иницијализује
   на вредност ``а[0]`` (важи :math:`m_0 = a_0`), што је заиста минимум
   једночланог префикса низа :math:`a`. Дакле, услови су задовољени пре
   првог извршавања тела петље.

-  Претпоставимо сада као индуктивну хипотезу да тврђење важи након
   :math:`k` извршавања тела петље. Дакле, претпостављамо да услови
   теореме важе за вредности :math:`m_k` и :math:`i_k` тј. да је
   :math:`1 \leq i_k \leq n` и да је :math:`m_k` једнако минимуму првих
   :math:`i_k` елемената низа (са :math:`i_k` и :math:`m_k` обележавамо
   вредности променљивих након :math:`k` извршавања тела петље). Ако је
   услов петље испуњен, то ће уједно бити и вредности променљивих на
   почетку тела петље, пре њеног :math:`k+1`-вог извршавања. Након
   :math:`k` извршавања тела петље важи да је :math:`i_k = k+1`, јер је
   променљива ``i`` имала почетну вредност :math:`1` и тачно :math:`k`
   пута је увећана за 1 (и ово би се формално могло доказати
   индукцијом).

   Из индуктивне хипотезе и претпоставке да је услов петље ``i < n``
   испуњен (тј. да је :math:`i_k < n`) докажимо да након :math:`k+1`
   извршавања тела петље услови теореме важе и за вредности
   :math:`m_{k+1}` и :math:`i_{k+1}` (са :math:`m_{k+1}` и
   :math:`i_{k+1}` обележавамо вредности променљивих након :math:`k+1`
   извршавања тела петље). Вредности :math:`m_{k+1}` и :math:`i_{k+1}`
   се могу лако одредити на основу вредности :math:`m_k` и :math:`i_k`,
   анализом једног извршавања тела петље. Важи да је
   :math:`i_{k+1} = i_{k} + 1 = k+2`. Зато, пошто је
   :math:`1 \leq i_k = k+1 < n`, важи и да је
   :math:`1 \leq i_{k+1} = k+2 \leq n`, па је услов који се односи на
   распон вредности променљиве ``i`` очуван. Докажимо и да је
   :math:`m_{k+1}` минимум првих :math:`i_{k+1}` елемента низа. Важи да
   је :math:`m_{k+1}` минимум вредности :math:`m_k` и елемента
   :math:`a_{i_k}`, тј. :math:`a_{k+1}`. На основу индуктивне хипотезе
   знамо да је :math:`m_k` минимум првих :math:`i_k = k+1` елемената
   низа. Зато ће :math:`m_{k+1}` бити минимум првих :math:`k+2`
   елемената низа (закључно са елементом :math:`a_{k+1}`), што је тачно
   :math:`i_{k+1}` елемената низа, па и други услов остаје очуван.

Означимо са :math:`i` и :math:`m` вредности променљивих ``i`` и ``m``
након извршавања петље. На основу доказаног тврђења знамо да услови
наведени у њему важе и након завршетка петље. Када се петља заврши, важи
да је :math:`i = n` (јер на основу првог услова знамо да је
:math:`1 \leq i \leq n`, а услов петље ``i < n`` није испуњен). На
основу другог услова знамо да је :math:`m` минимум :math:`n` чланова
низа (што је заправо цео низ, јер је :math:`n` његова дужина), тј. да
променљива ``m`` садржи тражену вредност, чиме је доказана парцијална
коректност. Заустављање се доказује једноставно тако што се докаже да се
у сваком кораку петље ненегативна вредност :math:`n-i` смањује за по 1,
док не постане 0.

Ако размотримо структуру претходног разматрања, можемо установити да смо
идентификовали логичке услове који су испуњени непосредно пре и
непосредно након сваког извршавања тела петље. Такви услови се називају
**инваријанте петље**. Да бисмо доказали да је неки услов инваријанта
петље, довољно је да докажемо:

(1) да тај услов важи пре првог уласка у петљу и

(2) да из претпоставке да тај услов важи пре неког извршавања тела петље
    и да је услов петље испуњен докажемо да тај услов важи и након
    извршавања тела петље.

Те две чињенице нам, на основу индуктивног аргумента, гарантују да ће
услов бити испуњен током сваке итерације петље, као и након извршавања
целе петље (ако се она икада заустави), тј. да ће тај услов бити
инваријанта петље (тај доказ се може спровести класичном математичком
индукцијом на основу броја извршавања тела петље). Приметимо да први
корак одговара доказивању базе индукције, а други доказивању индуктивног
корака.

Свака петља има пуно инваријанти, међутим, од интереса су нам само оне
инваријанте које у комбинацији са условом прекида петље (под
претпоставком да петља није прекинута наредбом ``break``) имплицирају
услов који нам је потребан након петље. Ако је петља једина у неком
алгоритму, обично је то онда услов коректности самог алгоритма. Дакле,
након доказа леме која чини основу доказа да је неки услов инваријанта
петље, потребно је да докажемо и

(3) да из тога да инваријанта важи након завршетка петље и да услов
    петље није испуњен следи коректност алгоритма.

Дакле, општа структура анализе програма коришћењем инваријанти се може
описати на следећи начин.

.. code:: csharp

   <incijalizacija>
   // ovde vazi <invarijanta>
   while (<uslov>) 
      // ovde vaze i <uslov> i <invarijanta>
      <telo>
      // ovde vazi <invarijanta>
   // ovde ne vazi <uslov>, a vazi <invarijanta>

Изолујмо кључне делове претходног доказа и прикажимо их у формату који
ћемо и убудуће користити приликом доказивања инваријанти петљи
(индукција ће у тим доказима бити само имплицитна).

**Лема:** Ако је низ :math:`a` дужине :math:`n \geq 1`, услов да је
:math:`1 \leq i \leq n` и да је :math:`m` минимум првих :math:`i`
елемената низа је инваријанта петље (где са :math:`i` обележавамо текућу
вредност променљиве ``i``, а са :math:`m` текућу вредност променљиве
``m``).

-  Пре уласка у петљу променљива ``i`` се иницијализује на :math:`1`
   (важи :math:`i = 1`). Пошто претпостављамо да је низ непразан, важи
   да је :math:`1 \leq i \leq n`. Променљива ``m`` се иницијализује на
   вредност ``а[0]`` (важи :math:`m = a_0`), што је заиста минимум
   једночланог префикса низа :math:`a`.

-  Претпоставимо да тврђење важи након уласка у петљу тј. да је вредност
   променљиве ``m`` (означимо је са :math:`m`) једнака минимуму првих
   :math:`i` чланова низа (где је :math:`i` вредност променљиве ``i`` на
   уласку у петљу), да је :math:`1 \leq i \leq n`, као и да је услов
   петље испуњен тј. да је :math:`i < n`.

   Пошто је након извршавања тела петље вредност променљиве ``i``
   увећана за један, важи да је :math:`i' = i + 1` (где са :math:`i'`
   обележавамо вредност променљиве :math:`i` након извршавања тела и
   корака петље). Пошто је важи да је :math:`i < n` и
   :math:`1 \leq i \leq n`, након извршавања тела петље, важиће да је
   :math:`1 \leq i' \leq n`.

   Нова вредност променљиве ``m`` (означимо је са :math:`m'`) биће
   једнака мањој од вредности :math:`m` и :math:`a_i`. На основу
   претпоставке важи да је :math:`m` једнако минимуму првих :math:`i`
   елемената низа, тј. минимуму бројева :math:`a_0`, …, :math:`a_{i-1}`,
   па је :math:`m'` једнако минимуму бројева :math:`a_0`, …,
   :math:`a_i`, што је управо минимум првих :math:`i+1` елемената низа,
   па је заиста :math:`m'` минимум првих :math:`i'` елемената низа.

**Теорема:** Након извршавања петље, променљива ``m`` садржи минимум
целог низа.

На основу инваријанте важи да је :math:`1 \leq i \leq n`, а пошто по
завршетку петље њен услов није испуњен, важи да је :math:`i = n`. На
основу инваријанте важи и да променљива ``m`` садржи минимум првих
:math:`i` елемената низа, а пошто је :math:`i = n`, где је :math:`n`
број чланова низа, то је заправо минимум целог низа.

У наставку овог поглавља видећемо још неколико примера примене технике
инваријанте петље. Мора се признати да када се техника користи потпуно
формално, да би се доказала коректност већ написаног програмског кода,
то не делује нарочито инспиришуће (поготово, ако су програми једноставни
и ако је једноставно интуитивно разумети аргументе њихове коректности).
Ретко када се у практичном програмирању коректност заиста доказује
потпуно формално (осим у случају софтвера који може да угрози велики
број живота, попут, на пример, софтвера који управља метро-системом у
Паризу, који јесте у потпуности формално верификован). Међутим,
аргументе и инваријанте на којима коректност почива програмер често
“проврти по глави”. Видећемо и да се техника инваријанти може употребити
и пре него што је програм написан у циљу извођења програмског кода из
спецификације. Јасне инваријанте често једнозначно указују како
програмски код мора да изгледа и на тај начин помажу у процесу
програмирања.

Задаци који су одабрани нису ни по чему посебни – они ће бити поновљени
у поглављима у којима се уводе опште програмерске технике које се у њима
примењују.
