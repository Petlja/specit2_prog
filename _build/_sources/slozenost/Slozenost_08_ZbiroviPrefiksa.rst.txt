
..
  2.8 Збирови префикса и разлике суседних елемената
  reading

Збирови префикса низа, разлике суседних елемената низа
======================================================

Збирови префикса низа
---------------------

Ако је дат низ елемената збир свих елемената у интервалу позиција
:math:`[a, b]` се може израчунати као разлика између збира свих
елемената у интервалу позиција :math:`[0, b]` и збира елемената у
интервалу позиција :math:`[0, a-1]`.

На пример, размотримо како да израчунамо збир елемената на позицијама из
интервала [3, 5] (тј. на позицијама 3, 4 и 5) у низу 4, 2, 3, 1, 5, 6,
9, 2. На тим позицијама се налазе елементи 1, 5 и 6 и збир им је
:math:`1+5+6 = 12`. Збир свих елемената из интевала позиција
:math:`[0, 5]` је :math:`4+2+3+1+5+6 = 21`, док је збир свих елемената
из интервала позиција :math:`[0, 2]` једнак :math:`4 + 2 + 3 = 9`.
Разлика :math:`21-9` управо је једнака 12.

Ова наизглед веома једноставна особина сабирања може значајно помоћи
убрзању разних алгоритама у којима су нам потребни збирови узастопних
елемената низа. Наиме, ако знамо *збирове свих префикса* низа тј.
збирове на свим интервалима :math:`[0, k)`, за :math:`k=0` до :math:`n`
(а њих можемо израчунати током фазе претпроцесирања, инкрементално, у
линеарној сложености), тада у константној сложености (једним одузимањем)
можемо израчунати збир произвољног сегмента низа.

Дакле, од датог низа, низ збирова префикса можемо израчунати у линеарној
сложености, али важи и обратно. Од низа префикса, у линеарној сложености
можемо израчунати елементе оригиналног низа. Важи чак и јаче тврђење од
тога, јер сваки конкретни елемент низа можемо наћи у константној
сложености, одузимањем два суседна збира префикса. Дакле, прелазак са
низа на збирове његових префикса можемо сматрати променом репрезентације
(нема смисла чувати и једно и друго истовремено у меморији).

Приметимо огромну сличност са интегралним и диференцијалним рачуном.
Израчунавање збирова префикса одговара одређеном интеграљењу, разлика
збирова префикса одговара Њутн-Лајбницовој формули, док израчунавање
разлике суседних елемената одговара диференцирању. Интеграљење и
диференцирање су међусобно инверзне операције.

Пример: збирови сегмената
~~~~~~~~~~~~~~~~~~~~~~~~~

Решимо овом техником наредни задатак.

**Задатак:** Позната је зарада једног предузећа током одређеног броја
дана. Напиши програм који омогућава кориснику да израчунава укупну
зараду предузећа у временским периодима одређеним почетним и крајњим
даном.

Улаз
~~~~

Са стандардног улаза се уноси број дана :math:`n (1 \leq n \leq
10^5)`, а затим у наредном реду n целих бројева између 0 и 100,
раздвојених са по једним размаком, који представљају зараде током
:math:`n` дана. Након тога се уноси број упита :math:`m (1 \leq m \leq
100000)` и у наредних :math:`m` редова се уносе временски периоди
одређени редним бројем почетног дана :math:`a` и крајњег дана
:math:`b` (:math:`0 \leq a \leq b < n`).

Излаз
~~~~~

На стандардни излаз исписати m целих бројева који представљају укупне
зараде у сваком од m периода.

Пример
~~~~~~

Улаз
````

::
   
   5
   1 2 3 4 5
   3
   0 4
   1 3
   2 2

Излаз
`````

::
   
   15
   9
   3

Решење
~~~~~~
   
.. code:: csharp

   using System;
    
   class Program
   {
       static void Main(string[] args)
       {
           int n = int.Parse(Console.ReadLine());
           int[] zbiroviPrefiksa = new int[n+1];
    
           zbiroviPrefiksa[0] = 0;
           for (int i = 0; i < n; i++)
           {
               int x = int.Parse(Console.ReadLine());
               zbiroviPrefiksa[i+1] = zbiroviPrefiksa[i] + x;
           }
    
           int m = int.Parse(Console.ReadLine());
           for (int i = 0; i < m; i++)
           {
               string[] str = Console.ReadLine().Split();
               int a = int.Parse(str[0]);
               int b = int.Parse(str[1]);
               Console.WriteLine(zbiroviPrefiksa[b+1] - zbiroviPrefiksa[a]);
           }
       }
   }

Разлике суседних елемената
--------------------------

Дуалан приступ збировима префикса је промена репрезентације у којој
уместо низа чувамо разлике суседних елемената. Повратак на оргинални низ
се онда може извршити у линеарној сложености тако што израчунамо збирове
префикса низа разлика. Ова репрезентација нам омогућава да веома
ефикасно мењамо сегменте низа тако што све елементе из неког задатог
сегмента увећамо или умањимо за неку фиксну вредност.


Пример: увећавање сегмената
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Камион превози терет током :math:`N` километара пута. На пут креће
празан и током пута утоварује и истоварује пакете. Ако се за сваки пакет
зна на ком је километру пута утоварен, на ком је километру пута
истоварен и колика му је маса, напиши програм који одређује колико је
оптерећење камиона на сваком километру пута. Сматрати да се предмет
утоварује на почетку, а истоварује на крају датог километра.

Улаз
~~~~

Са стандардног улаза се уноси број километара :math:`N`
(:math:`10\leq N 10000`), затим, у наредном реду, број предмета
:math:`M` (:math:`0 \leq M \leq 10000`), а након тога, у наредних
:math:`M` редова по три цела броја раздвојена размацима који
представљају број километра на чијем је почетку утоварен предмет (цео
број између :math:`0` и :math:`N-1`), број километра на чијем крају је
истоварен (цео број између :math:`0` и :math:`N-1`) и на крају маса
предмета (цео број између 1 и 10).

Излаз
~~~~~

На стандардни излаз исписати масу терета у килограмима на сваком
километру пута (иза сваке масе написати по један размак).

Пример
~~~~~~

Улаз
````

::

   10
   3
   1 5 10
   3 7 10
   2 8 15

Излаз
`````

::

   0 10 25 35 35 35 25 25 15 0

Објашњење
`````````

::

           km   0   1  2  3  4  5  9  7  8  9
                0   0  0  0  0  0  0  0  0  0
   1 5 10       0  10 10 10 10 10  0  0  0  0
   3 7 10       0  10 10 20 20 20 10 10  0  0
   2 8 15       0  10 25 35 35 35 25 25 15  0


Решење
~~~~~~

.. code:: csharp

   using System;
    
   class Program
   {
       static void Main(string[] args)
       {
           int n = int.Parse(Console.ReadLine());
           int[] razlika = new int[n+1];
           int m = int.Parse(Console.ReadLine());
           for (int i = 0; i < m; i++)
           {
               string[] str = Console.ReadLine().Split();
               int km_od = int.Parse(str[0]);
               int km_do = int.Parse(str[1]);
               int masa = int.Parse(str[2]);
               razlika[km_od] += masa;
               razlika[km_do+1] -= masa;
           }
    
           int masa_km = 0;
           for (int km = 0; km < n; km++)
           {
               masa_km += razlika[km];
               Console.Write(masa_km + " ");
           }
       }
   }
          
   
Покушај коришћењем ове две технике да ефикасно решиш задатке
са следеће странице.

.. comment

    - Аритметички троугао
    - Збирови сегмената
    - Максимални збир сегмента
    - Сегмент датог збира у низу целих бројева
    - Сегмент датог збира у низу природних бројева
    - Сегмент највећег збира дељивог дужином низа
    - Сегменти чији је збир дељив са k
    - Први сегмент дељив са N
    - Слаткиши за сав новац
    - Збирови правоугаоника
    - Пар производа у ранцу
    - Увећавање сегмената
    - Најбројнији пресек интервала
    - Пермутација са највећим збиром упита
