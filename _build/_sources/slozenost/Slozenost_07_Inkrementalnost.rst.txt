
..
  2.7 Инкременталност
  reading

Инкременталност
===============

Један од основних техника за избегавање лоше сложености алгоритама је да
се избегне израчунавање истих ствари више пута у истом програму. Често
је потребно израчунати неку вредност за различите вредности неког
параметра. Рећи ћемо да је израчунавање **инкрементално** ако се
резултујућа вредност за наредну вредност параметра израчунава коришћењем
већ израчунатих вредности за претходну (или неколико претходних)
вредности параметра. Дакле, на мале измене улазних података реагујемо
малим изменама резултата (уместо да поново вршимо велико израчунавање
свега, из почетка).

Веома једноставан пример принципа инкременталности је израчунавање
парцијалних збирова (збирови префикса) елемената неког низа. На пример,
ако је дат низ :math:`1, 2, 3, 4, 5`, његови парцијални збирови су редом
:math:`0, 1, 3, 6, 10, 15`. Веома једноставно се примећује да се
израчунавање наредног парцијалног збира не мора вршити сабирањем свих
елемената од почетка, већ се може добити сабирањем претходног
парцијалног збира са текућим елементом низа (на пример, збир
:math:`1+2+3+4 = 10`, се добија сабирањем претходног збира
:math:`1+2+3 = 6` и текућег елемента :math:`4`). Ако збир првих
:math:`k` елемената означимо са :math:`Z_k`, тада важи да је
:math:`Z_0 = 0` и да је :math:`Z_{k+1} = Z_k + a_k`. Овим смо добили
серију бројева у којој се наредни елемент израчунава на основу
претходног (или неколико претходних). За такве серије кажемо да су
*рекурентне серије*. Сваки наредни члан се израчунава у сложености
:math:`O(1)`, па се израчунавање свих парцијалних збирова низа дужине
:math:`n` врши у сложености :math:`O(n)`. Када би се сваки парцијални
збир рачунао сабирањем елемената низа из почетка, тада би израчунавање
:math:`k`-тог збира било сложености :math:`О(k)`, а израчунавање свих
збирова сложености :math:`O(n^2)`.

Принцип инкременталности је у тесној вези са индуктивно/рекурзивном
конструкцијом алгоритама и лежи у основи великог броја основних
алгоритама. Већ само израчунавање збира свих елемената низа заправо
почива на постепеном, инкременталном израчунавању збирова префикса, све
док се не израчуна збир свих елемената низа. Слично је и са
израчунавањем минумума, максимума, линеарном претрагом и другим
фундаменталним алгоритмима. У свим овим примерима крећемо од неке
почетне вредности у низу резултата, а затим наредну вредност у том низу
израчунавамо на основу претходне или неколико претходних, што директно
одговара индуктивном поступку израчунавања. Слична техника (добијања
наредних резултата на основу претходних) примењује се у склопу технике
динамичког програмирања навише, о чему ће више речи бити касније.

Пример: таблица факторијела
---------------------------

За сваки број од 1 до :math:`n` треба исписати његов факторијел.

Функција за израчунавање сваког факторијела засебно
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Једно решење је, да за сваки број :math:`k` рачунамо факторијел на
уобичајан начин, тако што множимо бројеве полазећи од 1 до
:math:`k`. Израчунавање факторијела можемо реализовати у посебној
функцији, што је у складу са добром праксом организовања кода, али је,
нажалост, у овом контексту неефикасно. Наиме, у кораку :math:`k`
вршимо :math:`k-1` множења, па укупно вршимо :math:`1 + 2 + \ldots +
(n-1)` тј. :math:`\frac{n(n-1)}{2}` множења, тако да је овај алгоритам
квадратне сложености :math:`O(n^2)`.

.. code:: csharp
          
   using System;

   class Program
   {
       static ulong faktorijel(int k)
       {
           ulong p = 1;
           for (int i = 2; i <= k; i++)
               p *= (ulong)i;
           return p;
       }
           
       static void Main(string[] args)
       {
           int n = int.Parse(Console.ReadLine());
           for (int k = 1; k <= n; k++)
               Console.WriteLine(faktorijel(k));
       }
   }

Инкрементално израчунавање серије факторијела
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Приметимо да је израчунавање свих потребних факторијела заправо
израчунавање парцијалних производа серије бројева :math:`1, 2, \ldots,
n.` Парцијалне производе можемо рачунати инкрементално.

Приликом израчунавања факторијела броја :math:`k`, ми заправо морамо
израчунати и факторијеле свих бројева мањих од :math:`k`. Тако на пример
приликом рачунања :math:`5!` треба да израчунамо
:math:`1 \cdot 2 \cdot 3 \cdot 4 \cdot 5`, а да бисмо то израчунали
потребно је да у неком тренутку знамо вредност производа
:math:`1 \cdot 2 \cdot 3 \cdot 4` тј. :math:`4!`. Можемо уочити да је
:math:`0! = 1` и да за :math:`k \geq 0` важи
:math:`(k+1)!=k!\cdot (k+1).` Међутим, :math:`k!` је управо вредност
коју смо рачунали у претходном кораку и заправо је довољно само
претходни производ помножити са 5. Ако са :math:`P_k` обележимо производ
првих :math:`k` природних бројева тј. :math:`k!,` важи да је
:math:`P_0 = 1` и :math:`P_{k+1} = P_k \cdot (k+1),` чиме добијамо
рекурентну серију. Да бисмо имплементирали инкрементално решење потребно
је памтити претходно израчунати факторијел. То реализујемо коришћењем
променљиве :math:`p`. На почетку поставимо :math:`p` на вредност 1.
Затим редом за сваки број :math:`k` од 1 до :math:`n`, претходни
факторијел помножимо са :math:`k` (:math:`p` добија вредност
:math:`p \cdot k`) прикажемо нову вредност факторијела, и наставимо
петљу даље.

Инкременталним решењем вршимо по једно множење у :math:`n` корака петље,
што даје алгоритам линеарне сложености :math:`O(n)`. Пошто је факторијел
веома брзо растућа функција у овом задатку се разлика не осећа на
тест-примерима (вредност :math:`n` је веома мала), међутим, у наредним
задацима видећемо како инкрементални приступ може значајно да унапреди
ефикасност решења.
   
.. code:: csharp

   using System;

   class Program
   {
       static void Main(string[] args)
       {
           int n = int.Parse(Console.ReadLine());
           ulong p = 1;
           for (int k = 1; k <= n; k++)
           {
               p *= (ulong)k;
               Console.WriteLine(p);
           }
       }
   }


Покушај да коришћењем принципа инкременталности ефикасно решиш 
задатке са следеће две странице.

.. comment

    - Префикс највећег збира
    - Сегмент датог збира у низу целих бројева
    - Факторијели од 1 до n
    - Хармонијски пи
    - Сума реда
    - Оптимални сервис
    - Рутер
    - Највећи тежински збир после цикличног померања
    - Дрва
    - Хиршов h-индекс
    - Најбољи “сабмит”
    - Поглед на реку
    - Ред особа
    - Попуњавање празнина
    - Добри такмичари
    - Максимални збир сегмента фиксираног почетка
    - Најдужа серија победа
    - Серија сјајних партија
    - Најдужи сегмент који садржи узастопне бројеве
    - Панграми
    - Пермутоване подниске
    - Број растућих сегмената
    - Минимуми правоугаоника
    - Суме трапеза
