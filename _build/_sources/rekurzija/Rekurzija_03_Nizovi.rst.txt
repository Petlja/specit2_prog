
..
  3.2 Рекурзија и низови
  reading

Рекурзија и низови
==================

У наставку ћемо приказати механизам анализе и обраде низова коришћењем
рекурзивних функција. И ови задаци би се у реалном програмирању
решавали коришћењем петљи, али помоћи ће нам да разумемо принцип
рекурзије и да се добро припремимо за њену примену на компликованијим
задацима.

.. questionnote::

   Дефиниши рекурзивну функцију која израчунава збир елемената
   целобројног низа.


Низ бројева је или празан или се може разложити на део низа без
последњег елемента и на последњи елемент. Дакле, слично као и у
случају рекурзивних функција са природним бројевима, можемо
разликовати случај нуле (излаз из рекурзије) и случај следбеника (тада
ћемо вршити рекурзивни позив). Збир празног низа је нула (неутрални
елемент за сабирање), док се збир ``a[0] + a[1] + ... + a[n-2] + a[n-1]``
може разложити на збир ``a[0] + a[1] + ... + a[n-2]`` (који израчунавамо
рекурзивним позивом) и на последњи елемент ``a[n-1]``. На основу ове
дискусије можемо дефинисати рекурзивну функцију за израчунавање збира.
   
.. code-block:: csharp

   // izracunava zbir prvih n elemenata niza a tj. zbir elemenata na
   // pozicijama [0, n)
   static int Zbir(int[] a, int n)
   {
      if (n == 0)
         return 0;
      return Zbir(a, n-1) + a[n-1];
   }

   // izracunava zbir svih elemenata niza a
   static int Zbir(int[] a)
   {
      return Zbir(a, a.Length);
   }


Кориснику који жели збир свих елемената низа поједностављујемо позив увођењем функције омотача 
(енгл. wrapper function) која иницира рекурзивне позиве тако што као
почетну вредност променљиве ``n`` прослеђује дужину низа (очитану
помоћу ``a.Length``).
  
Прикажимо корак по корак како се ова функција израчунава када се позове
за низ ``{5, 6, 4}``.

``Zbir({5, 6, 4}) =``

``Zbir({5, 6, 4}, 3) =``

``Zbir({5, 6, 4}, 2) + 4 =``

``(Zbir({5, 6, 4}, 1) + 6) + 4 =``

``((Zbir({5, 6, 4}, 0) + 5) + 6) + 4 =``

``((0 + 5) + 6) + 4 = (5 + 6) + 4 = 11 + 4 = 15``

Приметимо да се израчунавање врши на исти начин као и у случају
наредног итеративног поступка (уобичајеног за израчунавање вредности
збира) - збир се иницијализује на нулу и затим се редом увећава за један
по један елемент низа. 

.. code-block:: csharp

   // izracunava zbir elemenata niza a od pozicije i do kraja niza
   static int Zbir(int[] a)
   {
      int zbir = 0;
      foreach (int x in a)
         zbir += x;
      return zbir;
   }


Постоји и други начин да се организује рекурзија. Наиме, сваки
непразан низ можемо разложити на његов први елемент и низ елемената
иза њега. Дакле, збир ``a[0] + a[1] + ... + a[n-1]`` можемо разложити
на број ``a[0]`` и збир бројева ``a[1] + ... + a[n-1]``. Да би други
елемент низа могао да се сабере рекурзивним позивом, променићемо
параметре наше рекурзивне функције тако да поред низа прима почетну
позицију дела низа који се тренутно сабира. Дакле, њен задатак ће бити
да за дато ``i`` израчуна збир ``a[i] + a[i+1] + ... + a[n-1]``. Ако
је тај део низа празан тј. ако је ``i`` једнако дужини низа (њу увек
можемо очитати помоћу ``a.Length``), тада можемо извршити излаз из
рекурзије и вратити нулу. У супротном, збир разлажемо на елемент
``a[i]`` и остатак, па након тога рекурзивним позивом израчунавамо збир ``a[i+1] +
a[i+2] + ... + a[n-1]`` (у том рекурзивном позиву се низ не мења, али
се променљива ``i`` увећава за 1). Тиме добијамо наредни код.

.. code-block:: csharp

   // izracunava zbir elemenata niza a od pozicije i do kraja niza
   static int Zbir(int[] a, int i)
   {
      if (i == a.Length)
         return 0;
      return a[i] + Zbir(a, i+1);
   }
   
   // izracunava zbir svih elemenata niza a
   static int Zbir(int[] a)
   {
      return Zbir(a, 0);
   }

   
Прикажимо корак по корак како се ова функција израчунава када се позове
за низ ``{5, 6, 4}``.

``Zbir({5, 6, 4}) =``

``Zbir({5, 6, 4}, 0) =``

``5 + Zbir({5, 6, 4}, 1) =``

``5 + (6 + Zbir({5, 6, 4}, 2)) =``

``5 + (6 + (4 + Zbir({5, 6, 4}, 3))) =``

``5 + (6 + (4 + 0)) = 5 + (6 + 4) = 5 + 10 = 15``

Дакле, овај пут се израчунавање врши на исти начин као и у случају
наредног итеративног поступка - збир се иницијализује на нулу и затим
се редом увећава за један по један елемент низа, али овај пут не од
првог ка последњем, већ од последњег ка првом.

.. code-block:: csharp

   // izracunava zbir elemenata niza a od pozicije i do kraja niza
   static int Zbir(int[] a)
   {
      int zbir = 0;
      for (int i = a.Length - 1; i >= 0; i--)
         zbir += a[i];
      return zbir;
   }


.. questionnote::

   Дефиниши рекурзивну функцију која одређује највећи елемент
   непразног низа целих бројева.

Једини елемент једночланог низа је уједно његов највећи елемент, па
тај случај може бити излаз из рекурзије. Слично као у претходном
примеру, низ који има бар два елемента можемо разложити на елементе
који претходе последњем и на последњи елемент. Рекурзивно можемо
израчунати највећи елемент у делу низа без последњег елемента (тај део
је непразан, па се може извршити рекурзивни позив) и тако добијени
број упоредити са последњим елементом низа. Ако не обратимо пажњу,
можемо написати наредни програмски код.
  
.. code-block:: csharp

   // izracunava najveci od prvih n elemenata niza
   static int Maks(int[] a, int n)
   {
      if (n == 1)
         return a[0];
      if (Maks(a, n-1) > a[n-1])
         return Maks(a, n-1);
      else
         return a[n-1];
   }
   
   // izracunava zbir svih elemenata niza a
   static int Maks(int[] a)
   {
      return Zbir(a, 0);
   }

Иако исправан, овакав програм је веома неефикасан, јер се потпуно исти
рекурзивни позив често извршава два пута. Најнеповољнији случај је када је низ опадајући.
За опадајући низ приликом израчунавања ``Maks(a, n)`` два пута ће се извршити позив
``Maks(a, n-1)``. Сваки од тих позива ће два пута извршити ``Maks(a, n-2)``,
па ће тај позив бити извршен четири пута. Сваки од њих ће по два пута
позвати ``Maks(a, n-3)``, па ће тај позив бити извршен осам
пута. Дакле, примећујемо да ће позив ``Maks(a, n-k)`` бити позван
:math:`2^k` пута, што је веома много.

Ствар се може једноставно исправити тако што се резултат рекурзивног
позива упамти у помоћну променљиву.

.. code-block:: csharp

   // izracunava najveci od prvih n elemenata niza
   static int Maks(int[] a, int n)
   {
      if (n == 1)
         return a[0];
      int maks = Maks(a, n-1);
      if (maks > a[n-1])
         return maks;
      else
         return a[n-1];
   }
   
   // izracunava zbir svih elemenata niza a
   static int Maks(int[] a)
   {
      return Zbir(a, 0);
   }

Још лепше решење је оно које избегава употребу гранања и користи
библиотечку функцију ``Math.Max`` која израчунава максимум два броја.


.. code-block:: csharp

   // izracunava najveci od prvih n elemenata niza
   static int Maks(int[] a, int n)
   {
      if (n == 1)
         return a[0];
      return Math.Max(Maks(a, n-1), a[n-1]);
   }
   

Детаљнија објашњења решења ових и још неколико сличних задатака можеш
погледати на следећем видео-снимку.

.. ytpopup:: EFML15MHQZc
      :width: 735
      :height: 415
      :align: center
