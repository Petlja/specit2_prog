
..
  Динамичко програмирање - најдужи растући подниз
  reading

Најдужи растући подниз
======================

.. questionnote::

   Напиши програм који одређује најдужи строго растући подниз (не
   обавезно узастопних елемената) унутар датог низа. На пример, дужина
   најдужег растућег подниза низа `2, 6, 9, 5, 4, 3, 7, 2, 8` је 4 и
   један такав подниз је `2, 6, 7, 8`.


Квадратни алгоритам
'''''''''''''''''''
   
У првом решењу разматраћемо позицију по позицију у низу и одредићемо
најдужи растући подниз чији је последњи елемент на свакој од
њих. Приликом одређивања дужине најдужег растућег подниза који се
завршава на позицији :math:`i \geq 0`, претпоставићемо да за сваку
претходну позицију (ако их има) умемо да одредимо дужину најдужег
растућег подниза који се на њој завршава. Низ који се завршава на
позицији :math:`i` сигурно садржи елемент :math:`a_i`, а може
продужити све оне низове који се завршавају на некој позицији :math:`0
\leq j < i` ако је :math:`a_j < a_i`. Да би низ који се завршава на
позицији :math:`j` био што дужи, његов префикс који се завршава на
позицији :math:`j` мора бити што дужи (а дужине тих низова можемо
одредити рекурзивно). Зато од свих низова који се завршавају на
позицијама :math:`j` таквим да је :math:`a_j < a_i` одређујемо најдужи
и продужавамо га елементом :math:`a_i` (ако таквих елемената нема,
тада је најдужи низ који се завршава на позицији :math:`a_i`
једночлан).

.. code-block:: csharp

    // pronalazi duzinu najduzeg rastuceg podniza niza a koji se
    // zavrsava elementom na poziciji i
    static int najduziRastuciPodniz(int[] a, int i)
    {
        // podniz je sigurno duzine bar jedan (ako se uzme samo element a[i])
        int maksI = 1;
        // analiziramo da li je moguce da element a[i] produzuje neki
        // niz koji se zavrsio na nekoj ranijoj poziciji j elemenom a[j]
        for (int j = 0; j < i; j++)
            if (a[j] < a[i])
               maxI  = Math.Max(maxI, najduziRastuciPodniz(a, j) + 1);
        return maksI;
    }

    // pronalazi duzinu najduzeg rastuceg podniza
    static int NajduziRastuciPodniz(int[] a)
    {
        // podniz mora da se zavrsi na nekoj poziciji, tako da se za
        // svaku poziciju izracunava duzina podniza koji se zavrsava
        // na toj poziciji i odredjuje se najduzi od svih takvih podnizova
        int maks = 0;
        for (int i = 0; i < a.Length; i++)
            maks = Math.Max(maks, najduziRastuciPodniz(a, i));
        return maks;
    }

У претходном решењу долази до понављања идентичних рекурзивних позива,
па га је потребно оптимизовати техником динамичког програмирања. На
сајту Математичког факултета Универзитета у Београду можеш наћи
`апликацију
<http://www.matf.bg.ac.rs/~filip/algoritmi/dp/najduzi_rastuci.html>`__
која ће ти помоћи да разумеш како се то може урадити. Своје решење
можеш испробати у наредном `такмичењу на Петљи
<https://arena.petlja.org/competition/dp-rg2020-korona#tab_130154>`_. С
обзиром на то да је решење динамичким програмирањем засновано на
претходном поступку сложености :math:`O(n^2)`, неколико последњих
тест-примера неће моћи да се реше у предвиђеном времену.

Квазилинеарни алгоритам
'''''''''''''''''''''''

Ако се другачије приступи решавању задатка, могуће је направити решење
сложености :math:`O(n \log{n})`. Кључна идеја је да претпоставимо да
уз дужину :math:`d_{max}` најдужег растућег подниза до сада обрађеног
дела низа можемо за сваку дужину подниза :math:`1 \leq d \leq d_{max}`
да одредимо најмањи елемент којим се завршава неки растући подниз
дужине :math:`d`. Тиме добијамо низ елемената :math:`m_1, \ldots
m_{d_{max}}`. Приметимо да низ тих вредности увек строго растући (ако
постоји строго растући низ дужине :math:`d` који се завршава неким
елементом :math:`m_d`, тада се његов префикс дужине :math:`d-1` мора
завршавати неким елементом који је строго мањи од елемента
:math:`m_d`).

Обрађујемо редом елементе полазног низа. Приликом обраде елемента
:math:`a_i` знамо да он може последњи елемент подниза дужине
:math:`d_{max}+1` ако и само ако је строго већи од најмањег елемента
којим се може завршити неки подниз дужине :math:`d_{max}`, тј. ако је
строго већи од :math:`m_{d_{max}}`. У супротном он не може завршити
низ дужине :math:`d+1`, али можда може бити последњи елемент неког
подниза дужине :math:`d` између :math:`1` и :math:`d_{max}`, који је
мањи од дотадашњег најмањег елемента таквог подниза
:math:`m_d`. Дакле, у низу :math:`m_1, \ldots, m_{d_{max}}`, најмањих
завршетака низова дужина од 1 до :math:`d`, треба пронаћи први елемент
који је већи или једнак од :math:`a_i` и променити га на вредност
:math:`a_i`. Пошто је тај низ сортиран, проналажење таквог елемента
(тј. његове позиције) може се извршити бинарном претрагом, што даје
алгоритам сложености :math:`O(n\log{n})`. Ако такав елемент не
постоји, бинарна претрага враћа вредност :math:`d_{max} + 1`, па у
имплементацији није неопходно разликовати случајеве продужавања низа и
ажурирања неког његовог постојећег елемента.

На сајту Математичког факултета Универзитета у Београду можеш наћи
`апликацију
<http://www.matf.bg.ac.rs/~filip/algoritmi/dp/najduzi_rastuci_nlogn.html>`__
која ће ти помоћи да разумеш како овај поступак функционише (погледај
прво анимацију решења). Након тога имплементирај алгоритам и своје
решење испробај у наредном `такмичењу на Петљи
<https://arena.petlja.org/competition/dp-rg2020-korona#tab_130154>`_
(с обзиром на то да је овај алгоритам веома ефикасан, сви тест-примери
треба да се изврше у предвиђеном времену).

Нагласимо да низ најмањих завршних вредности није обавезно један
најдужи строго растући подниз полазног низа (иако он јесте строго
растући и дужина му је једнака дужини најдужег строго растућег
подниза). Нпр, ако је полазни низ :math:`1, 2, 0`, након извршења
алгоритма низ најмањих завршних вредности биће :math:`0, 2`, а најдужи
растући подниз је :math:`1, 2`. Да би се реконструисао сам најдужи
растући подниз, могуће је прилагодити програм тако да уместо вредности
најмањих завршетака памти њихове позиције у оригиналном низу, док у
додатном низу за сваки најмањи завршни елемент памтимо и позицију
претходног елемента у најдужем растућем поднизу (када се ажурира
:math:`m_d`, у низу се том елементу придружује :math:`m_{d-1}`,
тј. позиција на којој се тај елемент налази).
